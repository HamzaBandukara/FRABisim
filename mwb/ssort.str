functor SSort(structure Name : SoNAME;
	      structure Agent : SoAGENT;
		  sharing Agent.T.N = Name;
		  sharing Agent.Act.N = Name;
	      structure Env : ENV;
	      structure Slist : SORTEDLIST
	      structure Eqrel : EQREL) : SoSORT =
struct

    structure N = Name
    structure A = Agent
    structure T = Agent.T
    structure SL = Slist
    structure E = Env
    structure V = E.V
    structure EQ = Eqrel

    (* name of class (e.g. "Cons") and names in the class *)
    type eqclass = string * N.name list
    (* the obsort can be partially undefined, e.g. when expanding recursion *)
    datatype obsort = ObEmpty
		    | ObUndef
		    | ObDef of N.name * obsort ref
    (* a sorting is a mapping; just a list of eqclasses and their obsorts *)
    type sorting = (eqclass * obsort ref) list

    exception SortError of string
    exception NoObSort of string

    datatype polarity = Agent | Concretion | Abstraction
    fun po_mkstr Agent = "Agent"
      | po_mkstr Concretion = "Concretion"
      | po_mkstr Abstraction = "Abstraction"
	
    (* **** eqclass functions **** *)
    (* is n in the class? *)
    fun eq_isin (n,(_,class)) = SL.member N.le (n,class)
    (* add n to the class *)
    fun eq_add (n,(s,class)) = (s,SL.add N.le true (n,class))
    (* names of the class *)
    fun eq_names (_,class) = class
    (* name of the class *)
    fun eq_name (s,_) = s
    (* same eqclass? *)
    fun eq_same ((_,c1),(_,c2)) =
	Lib.eq N.eq (c1,c2)
    (* make an empty eqclass with name s *)
    fun empty_eqclass s = (s,[])
    fun eq_empty (_,[]) = true
      | eq_empty _ = false
    (* give a name to an eqclass *)
    fun name_eqclass s (t,class) =
	(if size t > 0 then if Flags.trace() then print ("*renaming eqclass "^t^" to "^s^"\n") else ()
	 else ();
	 (s,class))

    (* **** obsort **** *)
    fun empty_obsort () = ObEmpty
    fun is_empty_obsort ObEmpty = true
      | is_empty_obsort _ = false
    fun obsort_names ObEmpty = []
      | obsort_names ObUndef = []
      | obsort_names (ObDef(n,r)) = n::(obsort_names (!r))

    fun obsort_add (n,ob) = ObDef(n,ob)
    fun obsort_tail (ref (ObDef(n,r))) = r (* intentionally incomplete def *)

    fun undefined_obsort () = ObUndef
    fun obsort_undefined(ref ObUndef) = true
      | obsort_undefined _ = false


    (* **** sorting **** *)
    (* is the name n defined in the sorting s? *)
    and is_defined (n,s) =
	Lib.exists (fn (c,ob)=>
		    eq_isin(n,c) andalso not (obsort_undefined ob)) s

    (* find the eqclass of n in s *)
    and eqclass_of (n,s) =
	let fun find [] = empty_eqclass ""
	      | find ((c,_)::r) =
		if eq_isin(n,c)
		    then c
		else find r
	in
	    find s
	end

    (* return the obsort of n in s *)
    and obsort_of (n,s) =
	let fun find [] =
	    raise NoObSort ("obsort_of didn't find "^(N.mkstr n))
	      | find ((c,ob)::r) =
		if eq_isin (n,c)
		    then ob
		else find r
	in
	    find s
	end

    (* return both *)
    and eqob_of (n,s) =
	let fun find [] =
	    raise NoObSort ("eqob_of didn't find "^(N.mkstr n))
	      | find ((c,ob)::r) =
		if eq_isin (n,c)
		    then (c,ob)
		else find r
	in
	    find s
	end

    and in_same_eqclass(n,m,s) = 
	Lib.exists (fn (c,_) =>
		    eq_isin(n,c) andalso eq_isin(m,c)) s
	

    and obsort_eq (ObEmpty,ObEmpty,_) = true
      | obsort_eq (ObEmpty,ObDef _,_) = false
      | obsort_eq (ObDef _, ObEmpty,_) = false
      | obsort_eq (ObDef(n,r),ObDef(m,s),sort) =
	in_same_eqclass(n,m,sort) andalso obsort_eq(!r,!s,sort)
      | obsort_eq (_,_,_) = false

    and empty_sorting () = []


    and obsort_unify_one (n,B,s) =
	let fun obsort_unify_one (n,B as (ref ObUndef),_) =
	        (B := ObDef(n,ref ObUndef); B)
	      | obsort_unify_one (n,B as (ref ObEmpty),_) =
		raise SortError ("trying to unify "^(N.mkstr n)^" with an empty obsort")
	      | obsort_unify_one (n,B as (ref (ObDef(m,_))),s) =
		if in_same_eqclass(n,m,s) then B
		else
		    raise SortError ("trying to unify "^(N.mkstr n)^" with "^(N.mkstr m))
	    val _ = if !Flags.tracelevel >1 then Lib.dprint(1,"unify "^(N.mkstr n)^" with "^(ob_mkstrr B)^"\n") else ()
	    val XXX = obsort_unify_one(n,B,s)
	    val _ = if !Flags.tracelevel >1 then Lib.dprint(~1,"unify "^(N.mkstr n)^" with "^(ob_mkstrr B)^"=>"^(ob_mkstrr XXX)^"\n") else ()
	in XXX
	end
	
    (* unify ground obsort A with unground obsort B,
       or raise SortError. *)
    and obsort_unify (A,B,s) =
	let fun obsort_unify (ref A,B as (ref ObUndef), sort) =
	        (B := A; sort)
	      | obsort_unify (ref (ObDef(n,r)),B as (ref (ObDef(m,s))),sort) =
		if in_same_eqclass(n,m,sort) then obsort_unify(r,s,sort)
		else
		    obsort_unify(r,s,sort_mkeq(n,m,sort))
	      | obsort_unify (ref ObEmpty,ref ObEmpty,sort) =
		sort
	      | obsort_unify (A,B,sort) =
		raise SortError ("can't unify obsorts: "^(ob_mkstrr A)^" and "^(ob_mkstrr B))
		     
	    val _ = if !Flags.tracelevel >1 then Lib.dprint (1,"unify "^(ob_mkstrr A)^" and "^(ob_mkstrr B)^"\n") else ()
	    val XXX = obsort_unify(A,B,s)
	    val _ = if !Flags.tracelevel >1 then Lib.dprint(~1,"unify "^(ob_mkstrr A)^" and "^(ob_mkstrr B)^"=>"^(s_mkstr XXX)^"\n") else ()
	in XXX 
	end

    (* make a=b in the sorting sort *)
    and sort_mkeq(a,b,sort) =
	sort_lub(sort,add_eq_obsort(eq_add(a,eq_add(b,empty_eqclass "")),
				    ref(undefined_obsort()),
				    empty_sorting()))
(* 	let val (eq,ob) = eqob_of (b,sort)    *)
(* 	    val neq = (eq_add(a,eq),ob)       *)
(* 	    fun nsort [] = []                 *)
(* 	      | nsort ((ei,oi)::r) =          *)
(* 		if eq_same(ei,eq) then r      *)
(* 		else                          *)
(* 		    (ei,oi)::(nsort r)        *)
(* 	in                                    *)
(* 	    neq::(nsort sort)                 *)
(* 	end                                   *)

    (* add ([n]->ob) to s  *)
    and add_obsort (n,ob,s) =
	(let val (oldcl,oldob) = eqob_of(n,s)
	 in
	     if obsort_undefined(oldob) then
		 obsort_unify(ob,oldob,s)
	     else raise Lib.disaster ("add_obsort but "^(N.mkstr n)^" already defined")
	 end)
	     handle NoObSort _ =>
		 (eq_add(n,empty_eqclass ""),ob)::s

    and add_eq_obsort (eq:eqclass ,ob:obsort ref,s:sorting) =
	(let val n = Lib.hd (eq_names eq)
	     val (oldcl,oldob) = eqob_of(n,s)
	     fun remove_obundefs cl s =
		 let fun remo [] = []
		       | remo (((s,c),ob)::r) =
			 if Lib.eq N.eq (cl,c)
			     then if obsort_undefined ob
				      then r
				  else ((s,c),ob)::r
			 else ((s,c),ob)::(remo r)
		 in remo s
		 end
	 in
	     if obsort_undefined(oldob) then
		 (eq,ob)::(remove_obundefs (eq_names eq) s)
	     else raise Lib.disaster ("add_eq_obsort but "^(N.mkstr n)^" already defined")
	 end)
	     handle NoObSort _ =>
		 (eq,ob)::s

    (* **** printing **** *)
    and eq_mkstr (s,c) =
	if size s > 0 then s
	else if Lib.isnil(c) then "[Empty]"
	     else ("["^
		   (Lib.mapconcat N.mkstr c "=")(*(N.mkstr (Lib.hd c))*)
		   ^"]")
    and eq_mkstr_short (s,c) =
	if size s > 0 then s
	else if Lib.isnil(c) then "[Empty]"
	     else ("["^
		   (N.mkstr (Lib.hd c))^
		   (if Lib.isnil (Lib.tl c) then ""
		    else if length c = 2 then "="^(N.mkstr (Lib.hd(Lib.tl c)))
					(* likely shorter than "..." *)
			 else "=...")
		   ^"]")

    and ob_mkstr ob =
	let fun mk ObEmpty = ""
	      | mk ObUndef = "?"
	      | mk (ObDef(n,r)) =
		let val rr = !r
		in case rr of
		    ObEmpty => (N.mkstr n)
		  | _ => 
			(N.mkstr n)^","^(mk rr)
		end
	in
	    "("^(mk ob)^")"
	end
    and ob_mkstrr ob = ob_mkstr (!ob)
    and ob_prettystring sort (ref ObUndef) = "?"
      | ob_prettystring sort ob =
	let fun mk ObEmpty = ""
	      | mk ObUndef = "?"
	      | mk (ObDef(n,r)) =
		let val rr = !r
		    val eq = eqclass_of(n,sort)
		in (if eq_empty(eq) then N.mkstr n
		    else eq_mkstr_short(eq))^
		    (case rr of
			 ObEmpty => ""
		       | _ => ","^(mk (!r)))
		end
	in
	    "("^(mk (!ob))^")"
	end
    and s_mkstr [] = "{empty}"
      | s_mkstr s =
	let fun maks (cl,ob) =
	    (eq_mkstr cl)^"->"^(ob_prettystring s ob)
	in
	    if length s > 3 then
		"{"^(Lib.mapconcat maks s ",\n ")^"}"
	    else
		"{"^(Lib.mapconcat maks s ",")^"}"
	end


(*    fun fnjoin (new,old) = SL.merge N.le true (new,old) *)
    and fnadd (n,fnl) = SL.add N.le true (n,fnl)

    (* **** real stuff **** *)

    (* sort : agent * agent env * namedsort env -> sorting * obsort *)
    and sort (ag,agenv,sortenv) =
	let val (fr,ids,sigma,obs) =
	    sorter Agent (ag,(agenv,sortenv)) (A.free_names ag,ref E.empty)
	in
	    (sigma,!obs)
	end

    (* sorter : polarity -> (agent*(agent env*namedsort env)) -> (freenames * identifier sorts) -> (freenames * idsorts * sigma * obsort ref) *)
    and sorter PO (ag,env) (fnames,idsorts) =
	let val _ = if Flags.trace() then Lib.dprint(1,"sorter "^(po_mkstr PO)^" "^(A.mkstr ag)^"\n") else ()
	    val X as (fna,ids,sigm,ob) = zorter PO (ag,env) (fnames,idsorts)
	    val _ = if Flags.trace() then Lib.dprint(~1,"S: "^(s_mkstr sigm)^"\nOb: "^(ob_mkstrr ob)^"\n"^"IDs: "^(Lib.mapconcat (fn v=>(V.mkstr v)^": "^(ob_mkstrr(E.lookup (v,!idsorts)))) (E.getvars (!idsorts)) "\n    ")^"\n") else ()
	in X
	end
	    
    and zorter PO (ag,env as (agenv,sortenv)) (fnames,idsorts) =

	if A.is_nil(ag) then		(* ZERO rule *)
	    (fnames,idsorts,empty_sorting(),ref(empty_obsort()))

	else if A.is_prefix(ag) then	(* TAU/LOCn/COLOCn *)
	    if A.Act.is_tau(A.prefix_act(ag)) then
		let val X as (fna,ids,sigm,obs) =
		        sorter Agent (A.prefix_agent(ag),env) (fnames,idsorts)
		in
		    if is_empty_obsort(!obs) then X
		    else
			raise SortError ("non-empty obsort in TAU: "
					 ^(A.mkstr ag))
		end
	    else
		let val new as (fna,ids,sigm,obs) =
		    (sorter (if A.Act.is_input(A.prefix_act(ag))
				 then Abstraction
			     else Concretion)
		     (A.prefix_agent(ag),env) (fnames,idsorts))
		    val n = A.Act.name(A.prefix_act(ag))
		in (* #### also check name in sortenv *)
		    if is_defined(n,sigm) then
			let val oobs = obsort_of(n,sigm)
			in
			    (fna,ids,obsort_unify(obs,oobs,sigm),ref(empty_obsort()))
			    handle SortError s =>
				raise SortError ("name "^(N.mkstr n)^" gets new obsort in "^(A.mkstr ag)^"\n Old: "^(ob_mkstr (!oobs))^", New: "^(ob_mkstr (!obs))^"\n ("^s^")")
			end
		    else
			(fna,ids,add_obsort(n,obs,sigm),ref(empty_obsort()))
		end

	else if A.is_sum(ag) then		(* PLUS rule *)
	    let val pp = (A.sum_summands ag)
	    	val r0 as (f0,id0,sig0,ob0) = 
	    		 (sorter Agent (Lib.hd pp,env) (fnames,idsorts))
	    in
	    	if not (is_empty_obsort(!ob0))
	    	   then raise SortError ("non-empty obsort in PLUS: "^(A.mkstr (hd pp)))
	    	else
		(Lib.fold (fn (a,(fna,ids,sigm,obs)) =>
		       let val (fa,ia,sa,oa) = sorter Agent (a,env)(fna,ids)
		       in
			   if not (is_empty_obsort (!oa))
			       then raise SortError ("non-empty obsort in PLUS: "^(A.mkstr a))
			   else
			       (fa,ia,sort_lub(sigm,sa),oa)
		       end)
		(Lib.tl pp) r0)
	    end


	else if A.is_parallel(ag) then	(* COMP rule *)
	    let val pp = (A.parallel_pars ag)
	    	val r0 as (f0,id0,sig0,ob0) = 
	    		 (sorter Agent (Lib.hd pp,env)(fnames,idsorts))
	    in
	    	if not (is_empty_obsort(!ob0))
	    	   then raise SortError ("non-empty obsort in COMP: "^(A.mkstr (hd pp)))
	    	else
		(Lib.fold (fn (a,(fna,ids,sigm,obs)) =>
		       let val (fa,ia,sa,oa) = sorter Agent (a,env)(fna,ids)
		       in
			   if not (is_empty_obsort (!oa))
			       then raise SortError ("non-empty obsort in COMP: "^(A.mkstr a))
			   else
			       (fa,ia,sort_lub(sigm,sa),oa)
		       end)
		(Lib.tl pp) r0)
	    end

        else if A.is_restriction(ag) then (* RESn rule *)
	    let val (nn,ag1) = A.instantiate(A.restriction_name ag,
					     A.restriction_agent ag,
					     fnames)
	    in (* we must instantiate, since we assume all bound names different *)
		sorter PO (ag1,env) (fnadd(nn,fnames),idsorts)
	    end

	else if A.is_abstraction(ag) then (* ABS rule *)
	    (case PO of
		Concretion =>
		    raise SortError ("sorting expected a concretion, but found an abstraction: "^(A.mkstr ag))
	      | _ =>
		    let val (nn,ag1) = A.instantiate(A.abstraction_name ag,
						     A.abstraction_agent ag,
						     fnames)
			val (fna,ida,siga,obsa) =
			    sorter Abstraction (ag1,env) (fnadd(nn,fnames),idsorts)
			val sign = if is_defined(nn,siga) then siga
				   else add_obsort(nn,ref ObUndef,siga) (* just add a eqclass *)
		    in
			(fna,ida,sign,ref(obsort_add(nn,obsa)))
		    end)

	else if A.is_concretion(ag) then (* CONC rule *)
	    (case PO of
		Abstraction =>
		    raise SortError ("sorting expected an abstraction, but found a concretion: "^(A.mkstr ag))
	      | _ => 
		    let val (fna,ida,siga,obsa) =
			sorter Concretion (A.concretion_agent(ag),env)(fnames,idsorts)
			val n = A.concretion_name(ag)
			val sign = if is_defined(n,siga) then siga
				   else add_obsort(n,ref ObUndef,siga)
		    in
			(fna,ida,sign,ref(obsort_add(n,obsa)))
		    end)

	else if A.is_conditional(ag) then (* COND rule *)
	    let val (fna,ida,siga,obsa) =
		    sorter Agent (A.conditional_positive(ag),env) (fnames,idsorts)
		val (fnb,idb,sigb,obsb) =
		    sorter Agent (A.conditional_negative(ag),env) (fna,ida)
	    in
		if obsort_eq(!obsa,!obsb,sigb) then
		    (fnb,idb, sort_lub(siga,sigb), obsb)
		else raise SortError ("branches of conditional don't have same obsort: "^(A.mkstr ag))
	    end
			    
	else if A.is_application(ag) then (* APPL rule *)
	    let val arg = A.application_arg(ag)
		val (fr,ids,sigm,obs) =
		    sorter Abstraction (A.application_abstr(ag),env) (fnames,idsorts)
		val (nsigm,nobs) =
		    case (!obs) of
			ObDef(n,r) =>
			    (sort_mkeq(arg,n,sigm),
			     r)
		      | _ => 
			    (sigm,
			     obsort_tail(obsort_unify_one(arg,obs,sigm)))
		val XXX = (fr,ids,nsigm,nobs)
	    in
		case PO of
		    Concretion =>
			if is_empty_obsort(!nobs) then XXX
			else if obsort_undefined(nobs) then
			    (* note that this is the case where
			     the application should be a concretion;
			     the obsort should therefore be ground
			     *)
			    (fr,ids,obsort_unify(ref(empty_obsort()),nobs,nsigm),
			     ref(empty_obsort()))
			else
			    raise SortError ("sorting expected a concretion, but found an abstraction:\n "^(A.mkstr ag)^" : "^(ob_mkstr (!nobs)))
		  | _ => XXX
	    end

	else if A.is_identifier(ag) then (* ID rule *)
	    let val id = A.identifier_name ag
		val idobs = SOME(E.lookup(V.mkvar id, !idsorts))
			    handle E.Unbound _ => NONE
	    in
		case idobs of
		    SOME(obs) =>
			(fnames,idsorts,empty_sorting(),obs)
		  | NONE =>
			let val obs = ref ObUndef
			    val _ = idsorts := E.bind(V.mkvar id,obs,!idsorts)
			    val agdef = E.lookup(V.mkvar id,agenv)
			    val (fr,ids,sigm,nobs) =
				sorter Abstraction (agdef,env) (fnames,idsorts)
			    val sig' = obsort_unify(nobs,obs,sigm)
				handle SortError s =>
				    raise SortError
					("Identifier "^id^" gets new obsort:\n Old: "^(ob_mkstrr obs)^", New: "^(ob_mkstrr nobs)^"\n ("^s^")")
			in
			    (fr,ids,sig',nobs)
			end
	    end

	else 
	    raise Lib.disaster ("unknown agent in sorter")

    and sort_lub(sig1,sig2) = 
	let fun checkobs (o1,o2,r) =
	    let fun checkobs (ObEmpty,ObEmpty,r) = []
		  | checkobs (ObUndef,_,_) = []
		  | checkobs (_,ObUndef,_) = []
		  | checkobs (ObDef(xi,xr),ObDef(yi,yr),r) =
		    if not (EQ.implies(r,EQ.match(N.le,N.mkstr)(xi,yi))) then
			(xi,yi)::(checkobs(!xr,!yr,r))
		    else
			checkobs (!xr,!yr,r)
		  | checkobs (x,y,r) =
		    raise SortError "different length obsorts: no LUB"
		val x= checkobs(!o1,!o2,r)
	    in
		((*print ("checkobs ("^(ob_mkstrr o1)^","^(ob_mkstrr o2)^","^(EQ.mkstr r)^")\n => "^(Lib.mapconcat (fn (a,b)=>(N.mkstr a)^"="^(N.mkstr b)) x ",")^"\n");*)
		 x)
	    end
	    fun makerel (r,s1,s2) =
		let val rclasses = EQ.classes r
		    fun cko (n,m) = (checkobs (obsort_of(n,s1),
					       obsort_of(m,s2),r)
				     handle NoObSort s =>
					 ((*print ("**"^s^"\n");*)
					  []))
		    val newpairs =
			Lib.mapcan (fn (n::rclass)=>
				    (cko(n,n))@
				    (Lib.mapcan (fn m=>
						 (cko(n,m))@(cko(m,n)))
				     rclass))
			rclasses
		in
		    case newpairs of
			[] => r
		      | _ =>
			    let val newR =
				Lib.fold (fn ((m,n),r) =>
				      EQ.join(EQ.match (N.le,N.mkstr)(m,n),
					      r)) newpairs r
			    in
				makerel (newR,s1,s2)
			    end
		end
	    fun makeobs (r,s1,s2) =
		let fun update_obsorts ((eqci,obsi),s) =
		    let val n = Lib.hd(eq_names(eqci))
 			(* val _ = print("*u_obs ("^(eq_mkstr(eqci))^","^(ob_mkstrr obsi)^"),"^(s_mkstr s)^" (r="^(EQ.mkstr r)^")\n") *)
			val xxx =
			if is_defined(n,s) then s
			else
			    add_eq_obsort((eq_name(eqci),EQ.class_of(n,r)),
					  obsi, s)
		    in
			((*print(" => "^(s_mkstr xxx)^"\n");*)
			 xxx)
		    end
		in
		    Lib.fold update_obsorts s1 (Lib.fold update_obsorts s2
					    (empty_sorting()))
		end
	    fun eqclasses_to_eqrel s =
		let val mkmatch = EQ.match(N.le,N.mkstr)
		in
		    Lib.fold (fn (eqc,r) =>
			  let val hd = Lib.hd eqc
			  in
			      EQ.join(Lib.fold (fn (n,rel) =>
					    EQ.join(mkmatch(n,hd),rel))
				      (Lib.tl eqc) (mkmatch (hd,hd)),
				      r)
			  end) (map (fn (c,_)=>eq_names(c)) s)
		    (EQ.isEmpty(N.le,N.mkstr))
		end

	    fun foo () =
		let val _ = print("LUB "^(s_mkstr sig1)^","^(s_mkstr sig2)^"\n"^
				  " eqrels: "^(EQ.mkstr (eqclasses_to_eqrel sig1))^","^(EQ.mkstr(eqclasses_to_eqrel sig2))^"\n")
		    val r0 = EQ.join(eqclasses_to_eqrel sig1,eqclasses_to_eqrel sig2)
		    val _ = print(" joined: "^(EQ.mkstr r0)^"\n")
		    val rr = makerel (r0,sig1,sig2)
		    val _ = print(" R: "^(EQ.mkstr rr)^"...\n"^
				  " LUB: "^(s_mkstr(makeobs (rr,sig1,sig2)))^"\n")
		in () end
	in
	    if !Flags.tracelevel > 2 then foo() else ();
	    makeobs(makerel (EQ.join(eqclasses_to_eqrel sig1,
				     eqclasses_to_eqrel sig2),
			     sig1,sig2),
		    sig1,sig2)
	end
		  
end
