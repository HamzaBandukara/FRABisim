(* Open semantics of deBruinified agents.
   -- Bjorn Victor *)
functor OpenSem(structure B : OAGENT;
		     structure H : HASHTABLE;
		     structure C : COND;
		     sharing C.N = B.Act.N
		     sharing B.C = C
		     sharing B.Act.N = B.C.N) : OPENSEM =
struct
    structure B = B
    structure C = C

    structure Act = B.Act
    structure N = B.Act.N

    datatype commitment = Comm of C.cond * B.Act.action * B.agent

    (* String of a commitment *)
    fun c_mkstr (Comm(t,a,p)) =
	"|"^(if C.eq(t,C.True) then "" else (C.mkstr t))
	^">"^(Act.mkstr a)^"."^(B.mkstr p)
    fun cw_mkstr (Comm(t,a,p)) =
	"|"^(if C.eq(t,C.True) then "" else (C.mkstr t))
	^">>"^(Act.mkstr a)^"."^(B.mkstr p)
    fun c_makstr (Comm(t,a,p),fr) =
	"|"^(if C.eq(t,C.True) then "" else (C.makstr(t,fr)))
	^">"^(Act.makstr(a,fr))^"."^(B.makstr (p,fr))
    fun cw_makstr (Comm(t,a,p),fr) =
	"|"^(if C.eq(t,C.True) then "" else (C.makstr(t,fr)))
	^">>"^(Act.makstr(a,fr))^"."^(B.makstr(p,fr))

    (* commitment equality *)
    fun comm_eq(Comm(a,b,c),Comm(d,e,f)) = C.eq(a, d) andalso Act.eq(b, e) andalso B.eq(c, f)

    (* These are the hash tables that hold the "cache" of commitments, *)
    (* tau closures, and weak commitments. *)
    (* It is the caller's obligation to flush the tables *)
    (* (by calling cleartbls()) when the environment is changed. *)
    fun mktranstbl(sz) = H.maketable(sz,
				     (fn (c,p)=>B.hashval(p)),
				     (fn ((c1,p1),(c2,p2))=>
				      C.eq(c1,c2) andalso B.eq(p1,p2)),
				     (C.True,B.mk_nil()),
				     [Comm(C.True,Act.mk_tau(),B.mk_nil())])
    val commtbl = ref(mktranstbl(3))
    val tautbl = ref(mktranstbl(3))
    val weaktbl = ref(mktranstbl(3))

    fun cleartbls () =
	(commtbl := mktranstbl(3);
	 tautbl := mktranstbl(3);
	 weaktbl := mktranstbl(3))
    (* for debugging. *)
    fun desctbls() =
	let fun round(f) = ((Lib.mkstrint (trunc f))^"."
			    ^(Lib.mkstrint(trunc (100.0*
						   (f - (real (trunc f)))))))
	    fun desc(tb) =
	    (Lib.mkstrint (H.entrycount(tb)))
	    ^"/"^(Lib.mkstrint (H.bucketcount (tb)))
	    ^(if (H.entrycount (tb) > 0) then
	      " ("^(round (real (H.entrycount (tb))/real (H.bucketcount (tb))))^")"
	      else "")
	    ^" entries/buck"
	    ^", size "^(Lib.mkstrint (H.size (tb)))
	    ^(if (H.bucketcount (tb) > 0) then
	      " ("^(round (100.0*(real (H.bucketcount (tb))/real (H.size (tb)))))^"% full)"
	      else "")	    
	    ^(if (H.entrycount (tb) > 0) then
	      " ("^(round (real (H.entrycount (tb))/real (H.size (tb))))^" ent/size)"
	      else "")	    
	    ^", hits: "^(Lib.mkstrint (H.hits tb))
	    ^(if !Flags.tracelevel < 2 orelse (H.entrycount tb) > 10
		  then			(* just count empty slots *)
		      let val mpty = ref 0
		      in
			  (H.maphash (fn (k,v)=>
				    if null v then Lib.inc mpty else ()) tb);
			  if !mpty = 0 then ""
			  else ", "^(Lib.mkstrint (!mpty))^" empty"
		      end
	      else			(* print all slots *)
(* 		  Lib.fold (fn (s,r) => (s^r)) (H.maphash (fn (k,v)=> *)
(* 				      "\n" *)
(* 				      ^(B.mkstr k) *)
(* 				      ^"\n " *)
(* 				      ^(if null v then "[]" *)
(* 					else (Lib.mapconcat c_mkstr v "\n "))) *)
(* 						tb) *)
		  "")
	in
	    print("comm tbl: "^(desc (!commtbl))^"\n");
	    print("tau tbl: "^(desc (!tautbl))^"\n");
	    print("weak tbl: "^(desc (!weaktbl))^"\n")
	end
    val enabletbld = ref true
    fun enabletbls(b) = enabletbld := b
    fun enabledtbls() = !enabletbld

    (* val commitments : B.agent * B.env -> commitment list *)
    fun commitments C (ag,env) =
	let fun icommitments(ag,env) =
	    if B.is_process(ag,env) then
		if B.is_nil(ag,env) then []

		else if B.is_prefix(ag,env) then
		    [Comm(C.True,B.prefix_act(ag,env),B.prefix_agent(ag,env))]

		else if B.is_match(ag,env) then
		    let val m = B.match_test(ag,env)
		    in
			if C.is_false(C.join(C,m)) then []
			else
			    let val cl = commitments C (B.match_positive(ag,env),env)
			    in
				Lib.fold (fn (Comm(t,a,p),r) =>
				      Comm(C.join(m,t),a,p)::r)
				cl []
			    end
		    end

		else if B.is_sum(ag,env) then
		    Lib.mapcan (fn p=>commitments C (p,env))
		     (B.sum_summands(ag,env))

		else if B.is_parallel(ag,env) then
		    let fun par(Comm(t,a,p),q,revp) =
			Comm(t,a,B.mk_parallel(if revp then [q,p] else [p,q]))
			fun merge([],_) = []
			  | merge((pc as Comm(tp,ap,p))::cps,cqs) =
			    (let val pa = B.arity(p,env)
				 val pin = Act.is_input(ap)
				 val pout = Act.is_output(ap)
			     in
			     Lib.mapcan
			     (fn (qc as Comm(tq,aq,q)) =>
			      let val qa = B.arity(q,env)
			      in
				  if ((pin andalso Act.is_output(aq))
				      orelse
				      (pout andalso Act.is_input(aq)))
				      andalso pa = ~(qa)
				      andalso
				      not
				      (if !Flags.tracelevel>2 then
					   Lib.dprint(0,"IMPL: "^(C.mkstr C)^" => "^(C.mkstr(C.mismatch(Act.name(ap), Act.name(aq))))^" is "^(if (C.implies(C,C.mismatch(Act.name(ap), Act.name(aq)))) then "true" else "false")) else ();
				      (C.implies(C,C.mismatch(Act.name(ap),
							      Act.name(aq)))))
				      then
				  (* check that the
				   polarity of the prefix matches the arity of
				   the derivate *)
				  if (pin andalso pa < 0) orelse
				      (pout andalso pa > 0) then
				      (raise B.SemanticsError("*** polarity mixup:\n   "^(c_mkstr pc)^" <> "^(c_mkstr qc),q)) else
				  [Comm(C.join(C.match(Act.name(ap),
						       Act.name(aq)),
					       C.join(tp,tq)),
					Act.mk_tau(),
					B.pseudo_apply(p,q,env))]
				  else []
			      end) cqs
			     end)
			    @(merge(cps,cqs))
			val (p::qq) = B.parallel_pars(ag,env)
			val cp = commitments C (p,env)
			val cqs = commitments C (B.mk_parallel(qq),env)
		    in
			(merge(cp,cqs))
			@(map (fn c=> par(c,B.mk_parallel(qq),false)) cp)
			@(map (fn c=> par(c,p, true)) cqs)
		    end

		else if B.is_restriction(ag,env) then
		    let val cs = commitments (C.inc C) (B.restriction_agent(ag,env),env)
		    in
			(Lib.mapcan
			 (fn (c as (Comm(t0,a0,p))) =>
			  if Lib.exists N.zerop ((C.domain t0)@(Act.names a0))
			      then [] (* z in positive condition or in n(a0) *)
			  else
			  let val a = Act.beta_reduce a0 ([N.mkname("",~1)],0)
			      val t = C.beta_reduce t0 ([N.mkname("",~1)],0)
			      val f = B.free_names(p)
			  in
			      if not (Lib.exists N.zerop f) then
				  (* #### minimal rewriting, very often useful *)
				  (* restricted name not free, get rid of restriction *)
				  [Comm(t,a,B.beta_reduce p ([N.Zero],0))]
			      else
				  [Comm(t,a,B.mk_restriction(N.Zero,p))]
			  end)
			 cs)
		    end

		else if B.is_application(ag,env) then
		    (* this is an optimization - take all args at once *)
		    let val p = B.application_abstrs(ag,env)
			val a = B.application_args(ag,env)
		    in
			commitments C (B.apply(p,a,env),
				       env)
		    end
		     (* never happens *)
		     else raise Lib.disaster("unseen case in commitments("^(B.mkstr ag)^")")
	    else (* abstraction or concretion *)
		[]

          fun rewrite env a  =
	      (if !Flags.tracelevel > 3 then Lib.dprint(1,"rewrite "^(B.mkstr a)^"\n") else ();
		   let val x =
	      (if not (!Flags.rewrite)
		  then a
	      else if B.is_match(a,env) then
		  if C.eq (C.join(C,B.match_test(a,env)),C.True)
		      then B.match_positive(a,env)
		  else a
	      else if B.is_restriction(a,env) andalso B.is_process(a,env) then
		  let val Q = B.restriction_agent(a,env)
		      val f = B.free_names(Q) (* what a waste of time *)
		  in
		      if not (Lib.exists N.zerop f) then
			  (* restricted name not free, get rid of restriction *)
			  B.beta_reduce Q ([N.Zero],0)
		      else
			  let val c = commitments C (Q,env)
			  in if Lib.forall (fn Comm(t,a,Q')=>
					    not(Act.is_tau(a)) andalso
					    N.zerop(Act.name a)) c
				 (* only actions with restricted subject *)
				 then B.mk_nil()
			     else
				 a
			  end
		  end
	      else if B.is_parallel(a,env) then 
		  B.mk_parallel(map (rewrite env) (B.parallel_pars(a,env)))
	      else if B.is_sum(a,env) then
		  B.mk_sum(map (rewrite env) (B.sum_summands(a,env)))
		   else a)

	      in if !Flags.tracelevel > 3 then Lib.dprint(~1,(B.mkstr x)^"\n") else ();x end)

	in
	    if !Flags.tracelevel > 2 then Lib.dprint(1,"Comm "^(C.mkstr C)^"\n"^(B.mkstr ag)^"\n") else ();
		let val cmt =
	    case (if !enabletbld then H.gethash((C,ag),!commtbl) else NONE) of
		(* in the cache? *)
		SOME x => x
	      | NONE => 
		    (* no, compute it. *)
		    let val rc = icommitments (ag,env)
			val c =
			map (fn (Comm(t,a,p)) =>
			     Comm(t,a,rewrite env (B.std_form(p,env)))) rc
		    in
			(* save it and return it *)
			if !enabletbld then
			H.puthash((C,ag),c,!commtbl) else ();
			c
		    end
		in if !Flags.tracelevel > 2 then Lib.dprint(~1,"Comm:\n"^(Lib.mapconcat c_mkstr cmt "\n")^"\n") else ();
		    cmt
		end
	end

    (* #### replace mapunion by hashtables - unless it uses too much space? *)
    fun mapunion_comm f l =
	let val vt = H.maketable(3,fn Comm(_,_,a) => B.hashval a,
				 comm_eq,
				 Comm(C.True,Act.mk_tau(),B.mk_nil()),
				 true
				 )
(***	    fun tbdesc tb =
		("mapunion tbl: "^(makestring (H.entrycount tb))^" entries, "^(makestring (H.hits tb))^" hits\n")
	    fun time tb = (H.entrycount tb > 0 andalso H.entrycount tb mod 100 = 0) orelse (H.hits tb > 0 andalso H.hits tb mod 100 = 0)
	    val _ = inc Lib.dbglvl
***)
	    val _ = app (fn h =>
			 app (fn c=>
			      ((*if time vt then Lib.dprint(0,tbdesc vt) else ();*)
			       H.puthash(c,true,vt))) (f h)
			 ) l
	in
(* 	    Lib.dprint(~1,tbdesc vt);    *)
	    H.maphash (fn (k,v) => k) vt
	end
				 

    fun weakcomm C (P,env) =
	(if !Flags.tracelevel > 2 then Lib.dprint(1,"Wcomm "^(B.mkstr P)^"\n") else (); let val cmts =
	 case (if !enabletbld then H.gethash((C,P),!weaktbl) else NONE) of
	    SOME x => x
	  | NONE =>
		let fun mkabs (0,p) = p
		      | mkabs (n,p) = B.mk_abstraction(N.Zero,mkabs(n-1,p))
		    and mkcon (0,vl,p) = Lib.fold (fn (v,p)=>B.mk_concretion(v,p)) vl p
		      | mkcon (n,v,p) = B.mk_restriction(N.Zero,mkcon(n-1,v,p))
		    and mknames(0) = []
		      | mknames(n) = N.mkname("",~n)::(mknames (n-1))
		    fun fixend t0 (Comm(t,a,p)) =
			let val t1 = C.join(t,t0)
			in
			    if Act.is_tau(a) then []
			    else if Act.is_input(a) then
				let val (nv,b) = B.abs_all(p,env)
				    val ns = mknames(nv)
				in
				    Comm(t1,a,p)::
				    (Lib.mapcan (fn Comm(t,tau,p2) =>
					  (* beta reduce t by nv *)
					  let val tt = if nv=0 then t else C.beta_reduce t (ns,0)
					  in
					      if Lib.exists (fn n=>not(N.le(N.Zero,n))) (C.names tt) then []
					      else     
						  [Comm(C.join(tt,t1),a,
							if nv=0 then p2
							else
							    B.std_form(mkabs(nv,p2),env))]
					  end)
				     (tauclose C (b,env)))
				end
			    else (* if Act.is_output(a) then *)
				let val (nr,v,b) = B.conc_all(p,env)
				    val ns = mknames(nr)
				in
				    Comm(t1,a,p)::
				    (Lib.mapcan (fn Comm(t,tau,p2) =>
						 (* beta reduce t by nr *)
					  let val tt = if nr=0 then t else C.beta_reduce t (ns,0)
					  in
					      if Lib.exists (fn n=>not(N.le(N.Zero,n))) (C.names tt) then []
					      else
						  [Comm(C.join(tt,t1),a,
							B.std_form(mkcon(nr,v,p2),env))]
					  end)
				     (tauclose C (b,env)))
				end
			end

		    val c = 
			((*Lib.mapunion comm_eq*)
			 mapunion_comm
			 (fn (c as Comm(t0,tau,p0)) =>
			  c::(Lib.mapcan (fixend t0)
			      (commitments C (p0,env))))

			 ((Comm(C.True,Act.mk_tau(),B.std_form(P,env)))
			  ::(tauclose C (P,env))))
		in
		    if !enabletbld then H.puthash((C,P),c,!weaktbl) else ();
		    c
		end
    in if !Flags.tracelevel > 2 then Lib.dprint(~1,"Wcomm:\n"^(Lib.mapconcat cw_mkstr cmts "\n")^"\n") else ();
        cmts
    end)

    and tauclose C (P,env) =
	(if !Flags.tracelevel > 2 then Lib.dprint(1,"Tclose "^(B.mkstr P)^"\n") else ();
	 let val cmt =
	 case (if !enabletbld then H.gethash((C,P),!tautbl) else NONE) of
	    SOME x => x
	  | NONE => 
		let val vtab = (*[]*)
		        H.maketable(3,B.hashval,(B.ceq C),B.mk_nil(),true)
		    val ttab = H.maketable(3,fn Comm(_,_,a) => B.hashval a,
					   comm_eq,
					   Comm(C.True,Act.mk_tau(),B.mk_nil()),
					   true)
		    fun tbdesc vis =
			("tbl: "^(Lib.mkstrint (H.entrycount vis))^" entries, "^(Lib.mkstrint (H.hits vis))^" hits\n")
		    fun tbpred tb =
			H.entrycount tb mod 100 = 0 orelse (H.hits tb > 0 andalso H.hits tb mod 100 = 0)
		    fun member(x,y) =  (* Lib.member B.eq (x,y) *)
			case H.gethash(x,y) of
			    NONE => false 
			  | SOME z => z
		    fun add(x,y) = (* x::y*) (H.puthash(x,true,y); y)
		    fun tc vis t0 P =
			if member (P,vis) then ()
			else
			    let val vis' = add(P,vis)
			    in
			    app (*(*Lib.mapunion comm_eq *) mapunion_comm*)
			    (fn (C as Comm(t,a,p)) =>
			     if Act.is_tau(a) then
				 (add(Comm(C.join(t,t0),a,p),ttab);
				  (tc vis' (C.join(t,t0)) p))
			     else ())
			    (if !Flags.tracelevel > 2
				 then (if tbpred vis
					  then Lib.dprint (0,"Tclose vis "^(tbdesc vis))
				       else ();
				       if tbpred ttab
					  then Lib.dprint (0,"Tclose tt "^(tbdesc ttab))
				       else ())
			     else ();
			     (commitments C (P,env)))
			    end

		    val c = (tc vtab C.True P;
			     H.maphash (fn (k,v) => k) ttab)
		in
		    if !enabletbld then H.puthash((C,P),c,!tautbl) else ();
		    c
		end
	 in if !Flags.tracelevel > 2 then Lib.dprint(~1,"Tclose:\n"^(Lib.mapconcat c_mkstr cmt "\n")^"\n") else (); cmt
	 end)

(* ****************
    and tauclosett(P,env) =
	case (if !enabletbld then H.gethash(P,!tautbl) else NONE) of
	    SOME x => x
	  | NONE => 
		let val vtab = [] (* H.maketable(3,B.hashval,B.eq,B.mk_nil(),true) *)
		    val rtab = []
		    fun member(x,y) =  Lib.member B.eq (x,y)
			(* case H.gethash(x,y) of
			    NONE => false 
			  | SOME z => z *)
		    fun vcons(x,y) = x::y (* (H.puthash(x,true,y); y) *)
		    fun rcons(x,y) = x::y
		    fun tc vis P =	(* -> (comms,recpts) *)
			if member (P,vis) then ([],[])
			else
			    map (fn (C as Comm(t,a,p)) =>
			     if Act.is_tau(a) then
				 case H.gethash(p,!tautbl) of
				     SOME cl => 
					 (C::(map (fn (Comm(t1,a1,p1)) =>
						  Comm(C.join(t,t1),a1,p1))
					      cl),
					  [])
				   | NONE => 
					 if member (p,vis) then
					     ([C],[p])
					 else
					     let val (cl,recp) =
						 tc (vcons(P,vis)) p
						 val ccl = 
						     C::(map (fn (Comm(t1,a1,p1)) =>
							      Comm(C.join(t,t1),a1,p1))
							 cl)
					     in
						 app (fn q =>
						      if B.eq(P,q) then
							  let val qc = H.gethash(q,!tautbl)
							  in
							      H.puthash(q,union(ccl,qc),!tautbl)
							  end
						      else ()) recp;
						 H.puthash(p,cl,!tautbl);
						 (ccl,if not null recp then p::recp else recp)
					     end
			     else ([],[]))
			    (commitments C (P,env))

		    val c = (tc vtab P)
		in
		    if !enabletbld then H.puthash(P,c,!tautbl) else ();
		    c
		end
**************** *)

(* **** *)

    datatype CMatch = Succ of (B.agent * B.agent * C.cond) list
      		    | NoCMatch of commitment list

    exception Fail

    fun comm_match (C,c1 as Comm(M,a,p), QC,env) =
	let val CM = C.join(C,M)
	    fun act_match(N,a2) =
	    let val CMN = C.join(CM,N)
	    in
		(Act.is_tau(a) andalso Act.is_tau(a2)) orelse
		(Act.is_input(a) andalso Act.is_input(a2)
		 andalso C.implies(CMN,C.match(Act.name(a),Act.name(a2))))
		orelse
		(Act.is_output(a) andalso Act.is_output(a2)
		 andalso C.implies(CMN,C.match(Act.name(a),Act.name(a2))))
	    end
	    fun neverMatch(N,a2) =	(* this can never match if: *)
		let val CMN = C.join(CM,N)
		in
		    C.is_false(CMN) orelse (* the condition can't match *)
		    (* the polarities mismatch *)
		    (Act.is_tau(a) andalso not (Act.is_tau(a2)))
		    orelse
		    (Act.is_tau(a2) andalso not (Act.is_tau(a)))
		    orelse
		    (Act.is_input(a) andalso Act.is_output(a2))
		    orelse
		    (Act.is_input(a2) andalso Act.is_output(a))
		    orelse
		    ((not (Act.is_tau(a)) andalso not (Act.is_tau(a2)))
		     (* polarities match, but the names can never match *)
		     andalso
		     C.implies(CMN,C.mismatch(Act.name(a),Act.name(a2))))
		end
	    fun mkSucc(N,p,q) =
		(p,q,C.restrict_to(C.join(CM,N),
				   (B.free_names p)@(B.free_names q)))
	    val _ = if !Flags.tracelevel>2 then
		Lib.dprint(1,"comm_match "^(C.mkstr C)^":\n"^(c_mkstr c1)^" with\n"^
			   (Lib.mapconcat c_mkstr QC "\n")) else ()
	in
	    if not(C.implies(CM,C.disjunction(map (fn Comm(N,_,_)=>N) QC)))
		then (if !Flags.tracelevel > 1 then Lib.dprint(~1,"comm_match: "^(C.mkstr CM)^" doesn't imply "^(C.mkstr (C.disjunction(map (fn Comm(N,_,_)=>N) QC)))) else ();
		      NoCMatch (Lib.fold (fn (c as Comm(N,a2,q),l)=>
				      if neverMatch(N,a2) then c::l
				      else l) QC [])
		      )
	    else if Lib.forall (fn Comm(N,a2,q)=>act_match(N,a2)) QC then
		let val x = map (fn Comm(N,a2,q)=> mkSucc(N,p,q)) QC
		    val _ = if !Flags.tracelevel>2 then
			Lib.dprint(~1,"match successors:\n"^
				   (Lib.mapconcat (fn (p,q,l)=>"*"^(B.mkstr p)^"\n "^(B.mkstr q)^"\n+"^(C.mkstr l)) x "\n")) else ()
		in
		    Succ(x)
		end
	    else (if !Flags.tracelevel>2 then Lib.dprint(~1,"No match.")
		  else ();
		  NoCMatch (Lib.fold (fn (c as Comm(N,a2,q),l)=>
				  if neverMatch(N,a2) then c::l
				  else l) QC []))
	end

(* **** *)

    (* subsets of p of length n, no elements in b used *)
    fun nsubsets (n,b,p) =
	let fun minus (g,[]) = g
	      | minus (g,h::t) =
		minus (remove(h,g),t)
	    and remove(x,[]) = []
	      | remove (x,h::t) =
		if comm_eq(x,h) then t else h::(remove (x,t))

	    fun ns (0,_) = [[]]
	      | ns (n,[]) = []
	      | ns (n,h::t) =
		(map (fn l=>h::l) (ns (n-1,t)))@(ns (n,t))
	    val _ = if !Flags.tracelevel>2 then
		Lib.dprint(1,"nsubsets ("^(Lib.mkstrint n)^","^(Lib.mkstrint(length p))^")") else ();
	    val x = ns (n,minus(p,b))
	    val _ = if !Flags.tracelevel>2 then
		Lib.dprint(~1,"=> "^(Lib.mkstrint(length x))) else ();
	in
	    x
	end
		

    fun somebisimulation succfn wsuccfn (P,Q,env,C) =
	let val rmember =
	    Lib.member (fn ((a,c,e),(b,d,f)) =>
			(* if we've been here before with a weaker condition *)
			C.implies(e,f) andalso
			B.ceq f (a, b) andalso B.ceq f (c, d))
	    fun imember (x,l) =
		case H.gethash(x,l) of
		    NONE => false
		  | SOME z => z

	    val ihash = H.maketable(11,(fn(a,b,d)=>Lib.xorb(B.hashval(a),B.hashval(b))),
				    (fn ((a,c,e),(b,d,f)) =>
				     (* if we've been here before with a stronger condition *)
				     C.implies (f,e) andalso
				     B.ceq e (a, b) andalso B.ceq e (c, d)),
				    (B.mk_nil(),B.mk_nil(),C.True),true)
	    fun icons(tr as (P,Q,D),I) =
		((case H.gethash(tr,I) of
		      NONE => H.puthash(tr,true,I)
		    | SOME x => ());
		 I)

	    and add (P,Q,C) (R,I) =
		let fun succ P = succfn C (P,env)
		    and wsucc P = wsuccfn C (P,env)
		    val _ = if !Flags.tracelevel > 1 then
			Lib.dprint(1,"add "^(C.mkstr C)^" ("^(B.mkstr P)^","^(B.mkstr Q)^")\n") else ()

		(*      match p C wQsuc Psuc wQsuc (R,I) *)
		    fun match _ _ _ [] _ (R,I) = (R,I) (* Done *)
		      | match _ _ _ pc [] _ = (* no poss match *)
			(if !Flags.tracelevel > 1 then Lib.dprint(~1,"No possible match for\n["^(Lib.mapconcat c_mkstr pc ",")^"]\n") else ();
			 raise Fail)	(* I consing is done below *)
		      | match pair C Qsuc ((cP as Comm(m,a,p))::Pc) cQ (R,I) =
			let val cQl = length cQ
			    fun find n bad =
			    if (n> cQl) orelse (length bad = cQl)
				then
				    (if !Flags.tracelevel > 1 then Lib.dprint(~1,"No possible match for "^(c_mkstr cP)) else ();
				     raise Fail)	(* I consing is done below *)
			    else
				let val Qc = nsubsets(n,bad,cQ)
				    fun mq ([]) bad = find (n+1) bad
				      | mq (q::Qc) bad =
					case comm_match(C,cP,q,env) of
					    NoCMatch(never) => (* find other match *)
						(if !Flags.tracelevel>2 andalso not (null never) then
						     Lib.dprint(0,"can never match:\n "^(Lib.mapconcat c_mkstr never "\n ")) else ();
						mq Qc (never@bad))
					  | Succ(essors) => (* matches so far *)
						let val (r,i) =
						    ((Lib.fold (fn ((P',Q',C'),(R,I))=>
							    add (pair(P',Q',C')) (R,I))
						      essors (R,I))
						     handle Fail => (* Didn't, after all *)
						     ([],I))
						in
						    if null r then
							(app (fn (P',Q',C') =>
							      (icons(pair(P',Q',C'),I);()))
							 essors;
							 (* try other subset *)
							 mq Qc (q@bad))
						    else (* OK, try next Pc *)
							match pair C Qsuc Pc Qsuc (r,i)
						end
				in
				    if null Qc then
					find (1+(length cQ)) bad
				    else
					mq Qc bad
				end
			in find 1 []
			end
		in
		if rmember((P,Q,C),R) then
		    (if !Flags.tracelevel > 1 then Lib.dprint(~1,"already bisimilar") else ();
		     (R,I))
		else if imember((P,Q,C),I) then
		    (if !Flags.tracelevel > 1 then Lib.dprint(~1,"already NONbisimilar") else ();
		     raise Fail)
		else if B.is_process(P,env) andalso B.is_process(Q,env) then
		    let val Psuc = succ P
			val Qsuc = succ Q
			val wPsuc =  (wsucc P)
			val wQsuc =  (wsucc Q)

			val Pmatch = match (fn (a,b,c) => (a,b,c)) C wQsuc
			val Qmatch = match (fn (a,b,c) => (b,a,c)) C wPsuc
			val (r,i) = 
					      (* match P successors *)
			Qmatch Qsuc wPsuc (Pmatch Psuc wQsuc ((P,Q,C)::R,I))
		        (* then match Q successors *)
		    in
			if !Flags.tracelevel>1 then
			    Lib.dprint(~1,"result len "^(Lib.mkstrint(length r))) else ();
			(r,i)
		    end

		else if B.is_abstraction(P,env) andalso B.is_abstraction(Q,env) then
		    let val (vp,P'') = B.abs_all(P,env)
			val (vq,Q'') = B.abs_all(Q,env)
		    in
			if vp = vq then
			    let val _ = if vp = 0 then raise Lib.disaster("vp=0 in "^(B.mkstr P)) else ()
				val nns = N.n_newNamesNotin(vp,(B.free_names P)@(B.free_names Q))
				val P' = B.beta_reduce P'' (nns,0)
				val Q' = B.beta_reduce Q'' (nns,0)
			    in
				add (P',Q',C) (R,I)
			    end
			else (if !Flags.tracelevel > 4 then print("**abstraction mismatch: "^(Lib.mkstrint vp)^"<>"^(Lib.mkstrint vq)^"\n in "^(B.mkstr P)^"\n    "^(B.mkstr Q)^"\n") else ();
			      raise Fail)
		    end

		else if B.is_concretion(P,env) andalso B.is_concretion(Q,env) then
		    let val (np,vp,P'') = B.conc_all(P,env)
			val (nq,vq,Q'') = B.conc_all(Q,env)
			fun nceq (n1,n2) = C.implies(C,C.match(n1,n2))
		    in
			if np = nq andalso Lib.eq nceq (vp,vq) then
			    let val nns = N.n_newNamesNotin(np,(B.free_names P)@(B.free_names Q)@(C.names C))
				val P' = if np = 0 then P''
					 else B.beta_reduce P'' (nns,0)
				val Q' = if np = 0 then Q''
					 else B.beta_reduce Q'' (nns,0)
				val f =
(*  				    Lib.del_dups N.eq (vp@vq@(B.free_names P')@(B.free_names Q')) *)
    (* BV 060819: make new names distinct from all OTHER free names *)
				    Lib.del_dups N.eq (Lib.filter (fn x=> not(Lib.member N.eq (x,nns))) (vp@vq@(B.free_names P')@(B.free_names Q')))
				val C' = 
				    Lib.fold (fn (nn,c)=>
					  Lib.fold (fn (f,c)=>
						C.join(C.mismatch(nn,f),c))
					  f c) nns C
			    in
				add (P',Q',C') (R,I)
			    end
			else (if !Flags.tracelevel > 4 then print("**concretion mismatch: "^(Lib.mkstrint np)^"<>"^(Lib.mkstrint nq)^" or ["^(Lib.mapconcat N.mkstr vp ",")^"]<>["^(Lib.mapconcat N.mkstr vq ",")^"]\n") else ();
				  raise Fail)
		    end
		else
		    (print(">>Trying to match concretion with abstraction:\n>> "^(B.mkstr P)^"\n>> "^(B.mkstr Q)^"\n");
		     raise Fail)
	        end

	    val (R,I) = add (P,Q,C) ([],ihash)
	in
	    R
	end
    handle Fail => []

    fun somebisimilar succfn wsuccfn args =
	not (null (somebisimulation succfn wsuccfn args))

    val bisimulation = somebisimulation commitments commitments
    and bisimilar = somebisimilar commitments commitments
    and weakbisimulation = somebisimulation commitments weakcomm
    and weakbisimilar = somebisimilar commitments weakcomm
	
end
