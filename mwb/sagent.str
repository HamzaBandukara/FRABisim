functor StringAgent(structure Act : SACTION;
		    structure SL : SORTEDLIST) : SAGENT =
struct
	
   structure N = Act.N
   structure Act = Act

   datatype agent = Nil
     		  | Prefix of Act.action * agent
		  | Abs of N.name * agent
		  | Conc of N.name * agent
		  | Test of ((N.name * N.name) list * (N.name * N.name) list) * agent
                  | Sum of agent list
                  | Parallel of agent list
		  | Nu of N.name * agent
                  | AgentRef of string
		  | Applic of agent * N.name

   exception WrongArgs of string

   (* this should print polyadicity prettier *)
   fun mkstr(Nil) = "0"
     | mkstr(Prefix(a,P)) = (Act.mkstr a) ^ "." ^ (mkstr P)
     | mkstr(Abs(n,P)) = "(\\"^(N.mkstr n)^")"^(mkstr P)
     | mkstr(Conc(n,P)) = "["^(N.mkstr n)^"]"^(mkstr P)
     | mkstr(Test(t,P)) = (Tmkstr t) ^ (mkstr P)
     | mkstr(Sum(P)) = "(" ^ (Lib.mapconcat mkstr P " + ") ^ ")"
     | mkstr(Parallel(P)) = "(" ^ (Lib.mapconcat mkstr P " | ") ^ ")"
     | mkstr(Nu(n,P)) = "(^"^(N.mkstr n)^")"^(mkstr P)
     | mkstr(AgentRef(I)) = I
     | mkstr(Applic(P,arg)) =
       (case P of
	   AgentRef(I) => (mkstr P)
	 | Applic(P,n) => (mkstr P)
	 | _ => "("^(mkstr P)^")") ^ "<" ^ (N.mkstr arg) ^ ">"

   and Tmkstr (eq,neq) =
       "["
       ^(Lib.mapconcat (fn (a,b)=>(N.mkstr a)^"="^(N.mkstr b)) eq ",")
       ^(if null eq then "" else if null neq then "" else ",")
       ^(Lib.mapconcat (fn (a,b)=>(N.mkstr a)^"#"^(N.mkstr b)) neq ",")
       ^"]"

   and id x = x

   fun eq (Nil,Nil) = true
     | eq (Prefix(a,P),Prefix(b,Q)) =
       Act.eq(a,b) andalso eq(P,Q)
     | eq (Abs(a,P),Abs(b,Q)) =
       N.eq (a,b) andalso eq(P,Q)
     | eq (Conc(a,P),Conc(b,Q)) =
       N.eq (a,b) andalso eq(P,Q)
     | eq (Test(t1,P),Test(t2,Q)) =
       Teq(t1,t2) andalso eq(P,Q)
     | eq (Sum(P),Sum(Q)) =
       Lib.eq eq (P,Q)
     | eq (Parallel(P),Parallel(Q)) =
       Lib.eq eq (P,Q)
     | eq (Nu(n1,P1),Nu(n2,P2)) =
       N.eq (n1,n2) andalso eq(P1,P2)
     | eq (AgentRef(I1),AgentRef(I2)) = I1 = I2 
     | eq (Applic(P1,N1),Applic(P2,N2)) =
       eq (P1,P2) andalso N.eq (N1,N2)
     | eq (_,_) = false


   and d_le ((a,c),(b,d)) =		(* a<=b & (a<b | c<=d) *)
       N.le(a,b) andalso (not(N.le(b,a)) orelse N.le(c,d))
   and d_eq ((a,c),(b,d)) = N.eq(a,b) andalso N.eq(c,d)
   and Teq ((e1,n1),(e2,n2)) =
       Lib.eq d_eq ((SL.sort d_le true e1),(SL.sort d_le true e2))
       andalso
       Lib.eq d_eq ((SL.sort d_le true n1),(SL.sort d_le true n2))

end

