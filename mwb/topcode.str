functor TopCode(structure SL:SORTEDLIST
                structure Constant:CONSTANT
		structure V:VAR
		structure E:ENV
		sharing E.V = V
		structure SN:SNAME
		structure N:NAME
		structure T:TEST
		sharing T.N=N
		structure SAct:SACTION
		sharing SAct.N=SN
		structure Act:ACTION
		sharing Act.N=N
		structure SA:SAGENT
		sharing SA.Act=SAct
(* 		structure D:DISTINCTION    *)
(* 		sharing D.T=T              *)
		structure EQU:EQUIV
		sharing EQU.N = N
		structure FCond:COND
		sharing FCond.E=EQU
		sharing FCond.N = N
		structure A:OAGENT
		sharing A.C = FCond
		sharing A.Act=Act
		sharing A.E=E
		structure H:HASHTABLE
		structure SP:SPROPVAR
		sharing SP.A=SA
		structure SF:SFORMULA
		sharing SF.ACT=SAct
		sharing SF.P=SP
		structure McAgent:McAGENT
		sharing McAgent.B=T
		sharing McAgent.ACT=Act
		sharing McAgent.E = E
		sharing type McAgent.agent = A.agent
		structure PV:PROPVAR
		structure PF:PFORMULA
		sharing PF.P=PV
 		sharing PF.CST=Constant    
		sharing PF.ACT=Act
                structure F:FORMULA
		sharing F.P=PV
 		sharing F.CST=Constant    
		sharing F.ACT=Act
		structure NS:NAMESUBSTITUTION
		sharing NS.N=N
		sharing NS.B=T
		structure ASS:AGENTSUBSEM
		sharing ASS.A=McAgent
		sharing ASS.NS = NS
		structure Cond:CONDITION
		sharing Cond.NS = NS
		sharing Cond.F = F
		structure DF:DEF_LIST
		sharing DF.F=F
		structure SQ:SEQUENT
		sharing SQ.F=F
		sharing SQ.C=Cond
		sharing SQ.D=DF
		sharing SQ.A=McAgent
		structure MC:MODELCHECKER
		sharing MC.S=SQ
		sharing MC.AS=ASS
(*		structure EQ:EQUIVALENCECHECKER 
		sharing EQ.MC=MC *)
		structure NE:NAMEEQUATION
		structure SEQ:SEQ
		sharing SEQ.NE=NE
		sharing SEQ.A=McAgent
		sharing SEQ.F=PF
		sharing SEQ.N=N
		sharing SEQ.CST=Constant
		sharing SEQ.ACT=Act
		sharing SEQ.E=E
		sharing SEQ.AS=ASS
		sharing SEQ.NS=NS
		structure PROVER:PROVER 
		sharing PROVER.A=McAgent
		sharing PROVER.F=PF
		sharing PROVER.N=N
		sharing PROVER.S=SEQ
		sharing PROVER.NE=NE
		sharing PROVER.ACT=Act
		sharing PROVER.B=T
		sharing PROVER.E=E
		sharing PROVER.AS=ASS
		sharing PROVER.NS=NS
		sharing PROVER.CST=Constant	
		structure SoN:SoNAME
		structure SoAct:SoACTION
		sharing SoAct.N = SoN
		structure SoT:SoTEST
		sharing SoT.N = SoN
		structure SoA:SoAGENT
		sharing SoA.T = SoT
		sharing SoA.Act = SoAct
		structure EqR:EQREL
		structure SS:SoSORT
		sharing SS.N = SoN
		sharing SS.A = SoA
		sharing SS.E = E
		structure Cmd:COMMANDS
		sharing Cmd.A=SA
		sharing Cmd.F=SF
(* 		structure PILrVals : PI_LRVALS     *)
(* 		structure PILex : ARG_LEXER        *)
(* 		structure PIParser : ARG_PARSER    *)
		structure O:OPENSEM
		sharing O.B=A
		sharing O.C=FCond
(* 		sharing O.D=D    *)
		structure FAct:FACTION
		sharing FAct.N=N
		structure FA:FAGENT
		sharing FA.Act=FAct
		sharing FA.E=E
		sharing FA.T = FCond
		structure Fsem:FUSIONSEM
		sharing Fsem.A = FA
		sharing Fsem.A.T.N=N
		sharing Fsem.C = FCond
		structure SFAct:SFACTION
		sharing SFAct.N = SN
		structure SFA:SFAGENT
		sharing SFA.Act = SFAct
		sharing Cmd.FA = SFA
		    ) (* : TOPCODE *) =
struct

	(* **** the reason why these are still here instead of
	 being args to the functor, is that the ARG_LEXER signature
	 hides the PILex.lexarg type, making it impossible to use makeLexer. *)
	structure PILrVals =
	    PILrValsFun(structure Token = LrParser.Token
			structure Agent = SA
			structure SFAgent = SFA
			structure Commands = Cmd
			structure Prop = SP
			structure F = SF)

	structure PILex =
	    PILexFun(structure Tokens = PILrVals.Tokens)

	structure PIParser =
	    JoinWithArg(structure ParserData = PILrVals.ParserData
		 structure Lex = PILex
		 structure LrParser = LrParser)
	(* **** *)


	exception Quit of A.agent E.env * SoA.agent E.env *
		      (FA.agent * int) E.env * (SFA.agent * SN.name list) E.env


	exception PostParse of string

	val version = ref "Development version"

	fun read_line() =
	    let val line = case TextIO.inputLine TextIO.stdIn of
			       SOME x => x
			     | NONE => ""
		fun scan_line nil = nil
		  | scan_line ([#"\n"]) = nil
		  | scan_line (hd::rst) = hd::(scan_line rst)
	    in
		implode(scan_line(explode line))
	    end


(* ****
	fun check_args(a,e) =
	    Lib.fold (fn (i,bo) =>
		 let val (par,body) = E.lookup(i,e)
		     val spar = SL.sort N.le true par
		     val free = A.free_names(body)
		     val forgot = SL.minus (fn x=>x) N.le (free,spar)
		 in
		     (Lib.isnil(forgot)
		      orelse (print ("Error: Definition of "^(V.mkstr i)^" lacks args for the free names ("^(Lib.mapconcat (fn n=>let val s=(N.pretty_name n) in if size s > 0 then s else (N.mkstr n) end) forgot ",")^")\n");
			      false))
		     andalso bo
		 end) (E.getvars e) true
**** *)

	(* post-parsing SA->SoA *)
	fun postparse_to_sort (ag) =
	    let fun postparse_to_sort_act(SAct.Tau) = SoAct.mk_tau()
		  | postparse_to_sort_act(SAct.Input n) =
		    SoAct.mk_input(SoN.mkname(SN.mkstr n))
		  | postparse_to_sort_act(SAct.Output n) =
		    SoAct.mk_output(SoN.mkname(SN.mkstr n))
		and ppname(n) = SoN.mkname(SN.mkstr n)
		and postparse_to_sort_test((eq,neq)) =
		    Lib.fold (fn ((a,b),t) =>
			  SoT.join(SoT.match(ppname a,ppname b),
				   t))
		    eq
		    (Lib.fold (fn ((e,f),t) =>
			   SoT.join(SoT.mismatch(ppname e,ppname f),
				    t))
		     neq SoT.True)
	    in
		case ag of
		    SA.Nil => SoA.mk_nil()
		  | SA.Abs(n,P) =>
			SoA.mk_abstraction(SoN.mkname (SN.mkstr n),
					   postparse_to_sort P)
		  | SA.Nu(n,P) =>
			SoA.mk_restriction(SoN.mkname (SN.mkstr n),
					   postparse_to_sort P)
		  | SA.Prefix(a,P) =>
			SoA.mk_prefix(postparse_to_sort_act a,
				      postparse_to_sort P)
		  | SA.Conc(n,P) =>
			SoA.mk_concretion(SoN.mkname (SN.mkstr n),
					  postparse_to_sort P)
		  | SA.Test(b,P) =>
			SoA.mk_match(postparse_to_sort_test b,
				    postparse_to_sort P)
(* 		  | SA.Cond(b,P,Q) =>                                   *)
(* 			SoA.mk_conditional(postparse_to_sort_test b,    *)
(* 					   postparse_to_sort P,         *)
(* 					   postparse_to_sort Q)         *)
		  | SA.Sum(PP) =>
			SoA.mk_sum(map postparse_to_sort PP)
		  | SA.Parallel(PP) =>
			SoA.mk_parallel(map postparse_to_sort PP)
		  | SA.Applic(P,n) =>
			SoA.mk_application(postparse_to_sort P,
					   SoN.mkname (SN.mkstr n))
		  | SA.AgentRef i =>
			SoA.mk_identifier i
	    end


	fun bbruin_fagent(ag,fenv) =
	    let val fcount = if E.isempty (!fenv) then ref ~1
			     else ref(~(Lib.max (op >=) 
					(map (fn v => E.lookup(v,!fenv))
					 (E.getvars (!fenv)))))
		fun idx (n,e) = E.lookup(V.mkvar(SN.mkstr n),e)
		    handle E.Unbound v =>
			E.lookup(v,!fenv) handle E.Unbound v =>
			    (Lib.inc fcount;
			     fenv := E.bind(v,~(!fcount),!fenv);
			     ~(!fcount))
		and bind (n,v,e) = E.bind(V.mkvar(SN.mkstr n),v,e)

		and bb_name(n,lvl,env) =
		    N.mkname(SN.mkstr n,lvl-idx(n,env))
		fun bbruin_agent (SFA.Nil,n,e) = FA.mk_nil()
		  | bbruin_agent (SFA.Scope(n,P),lvl,env) =
		    FA.mk_scope(N.mkname(SN.mkstr n,lvl+1),
				bbruin_agent(P,lvl+1,bind(n,lvl+1,env)))
		  | bbruin_agent (SFA.Prefix(ac,A),lvl,env) =
		    FA.mk_prefix(bbruin_fact(ac,lvl,env),bbruin_agent(A,lvl,env))
		  | bbruin_agent (SFA.Conc(n,P),lvl,env) =
		    FA.mk_concretion(map (fn n=> bb_name(n,lvl,env))
				     n, bbruin_agent(P,lvl,env))
		  | bbruin_agent (SFA.Match(b,P),lvl,env) =
		    FA.mk_match(bbruin_fmatch(b,lvl,env),
				bbruin_agent(P,lvl,env))
		  | bbruin_agent (SFA.Sum(PP),lvl,env) =
		    FA.mk_sum(map (fn P=>bbruin_agent(P,lvl,env)) PP)
		  | bbruin_agent (SFA.Parallel(PP),lvl,env) =
		    FA.mk_parallel(map (fn P=>bbruin_agent(P,lvl,env)) PP)
		  | bbruin_agent (SFA.Applic(P,n),lvl,env) =
		    let val nl = map (fn n=> bb_name(n,lvl,env)) n
		    in
			FA.mk_application(bbruin_agent(P,lvl+(length n),env),nl)
		    end
		  | bbruin_agent (P as SFA.AgentID(I),_,_) =
		    FA.mk_identifier(I)

		and bbruin_fact(SFAct.Fusion f,lvl,e) =
		    FAct.mk_fusion(map (fn (a,b)=>bb_name(a,lvl,e)) f,
				   map (fn (a,b)=>bb_name(b,lvl,e)) f)
		  | bbruin_fact(SFAct.Input(n),lvl,e) =
		    FAct.mk_input(bb_name(n,lvl,e))
		  | bbruin_fact(SFAct.Output(n),lvl,e) =
		    FAct.mk_output(bb_name(n,lvl,e))
		and bbruin_fmatch((eq,neq),lvl,e) =
		    Lib.fold (fn ((a,b),m) =>
			  FCond.join(FCond.match(bb_name(a,lvl,e),bb_name(b,lvl,e)),m))
		    eq
		    (Lib.fold (fn ((a,b),m)=>
			   FCond.join(FCond.mismatch(bb_name(a,lvl,e),bb_name(b,lvl,e)),m))
		     neq FCond.True)
	    in
		bbruin_agent(ag,0,E.empty)
	    end


	(* post-parsing fun SA -> B; #### should be in pi.grm *)
	fun bbruin_agent(ag,fenv) =
	    let val fcount = if E.isempty (!fenv) then ref ~1
			     else ref(~(Lib.max (op >=) 
					(map (fn v => E.lookup(v,!fenv))
					 (E.getvars (!fenv)))))
		fun idx (n,e) = E.lookup(V.mkvar(SN.mkstr n),e)
		    handle E.Unbound v =>
			E.lookup(v,!fenv) handle E.Unbound v =>
			    (Lib.inc fcount;
			     fenv := E.bind(v,~(!fcount),!fenv);
			     ~(!fcount))
		and bind (n,v,e) = E.bind(V.mkvar(SN.mkstr n),v,e)
		fun bbruin_agent (SA.Nil,n,e) = A.mk_nil()
		  | bbruin_agent (SA.Abs(n,P),lvl,env) =
		    A.mk_abstraction(N.mkname(SN.mkstr n,lvl+1),
				     bbruin_agent(P,lvl+1,bind(n,lvl+1,env)))
		  | bbruin_agent (SA.Nu(n,P),lvl,env) =
		    A.mk_restriction(N.mkname(SN.mkstr n,lvl+1),
				     bbruin_agent(P,lvl+1,bind(n,lvl+1,env)))
		  | bbruin_agent (SA.Prefix(ac,A),lvl,env) =
		    A.mk_prefix(bbruin_act(ac,lvl,env),bbruin_agent(A,lvl,env))
		  | bbruin_agent (SA.Conc(n,P),lvl,env) =
		    A.mk_concretion(N.mkname(SN.mkstr n,lvl-idx(n,env)),
				    bbruin_agent(P,lvl,env))
		  | bbruin_agent (SA.Test(b,P),lvl,env) =
		    A.mk_match(bbruin_bool(b,lvl,env),
			       bbruin_agent(P,lvl,env))
(* 		  | bbruin_agent (SA.Cond(b,P,Q),lvl,env) =      *)
(* 		    A.mk_conditional(bbruin_bool(b,lvl,env),     *)
(* 				     bbruin_agent(P,lvl,env),    *)
(* 				     bbruin_agent(Q,lvl,env))    *)
		  | bbruin_agent (SA.Sum(PP),lvl,env) =
		    A.mk_sum(map (fn P=>bbruin_agent(P,lvl,env)) PP)
		  | bbruin_agent (SA.Parallel(PP),lvl,env) =
		    A.mk_parallel(map (fn P=>bbruin_agent(P,lvl,env)) PP)
		  | bbruin_agent (SA.Applic(P,n),lvl,env) =
		    A.mk_application(bbruin_agent(P,lvl,env),
				     N.mkname(SN.mkstr n,lvl-idx(n,env)))
		  | bbruin_agent (P as SA.AgentRef(I),_,_) =
		    A.mk_identifier(I)
		and bbruin_act(SAct.Tau,lvl,e) = Act.mk_tau()
		  | bbruin_act(SAct.Input(n),lvl,e) =
		    Act.mk_input(N.mkname(SN.mkstr(n),lvl-idx(n,e)))
		  | bbruin_act(SAct.Output(n),lvl,e) =
		    Act.mk_output(N.mkname(SN.mkstr(n),lvl-idx(n,e)))
		and bb_name(n,lvl,env) =
		    N.mkname(SN.mkstr n,lvl-idx(n,env))
		and bbruin_bool(b,lvl,e) =
		    (case b of
			 ([],[]) => FCond.False
		       | (eq,neq) => 
			     Lib.fold (fn ((a,b),m) =>
				    FCond.join(FCond.match(bb_name(a,lvl,e),bb_name(b,lvl,e)),m))
			     eq
			     (Lib.fold (fn ((a,b),m)=>
				    FCond.join(FCond.mismatch(bb_name(a,lvl,e),bb_name(b,lvl,e)),m))
			      neq FCond.True))
	    in
		bbruin_agent(ag,0,E.empty)
	    end

	fun bbruin_nlist(nl,fenv) =
	    let val fcount = if E.isempty(!fenv) then ref ~1
			     else ref(~(Lib.max (op >=) 
					(map (fn v => E.lookup(v,!fenv))
					 (E.getvars (!fenv)))))
		fun idx (n) = ~(E.lookup(V.mkvar(SN.mkstr n),!fenv))
		    handle E.Unbound v =>
			(Lib.inc fcount;
			 fenv := E.bind(v,~(!fcount),!fenv);
			 (!fcount))
	    in
		map (fn n=>N.mkname(SN.mkstr n,idx n)) nl
	    end
	fun bbruin_plist(nl,fenv) =
	    let val fcount = if E.isempty(!fenv) then ref ~1
			     else ref(~(Lib.max (op >=) 
					(map (fn v => E.lookup(v,!fenv))
					 (E.getvars (!fenv)))))
		fun idx (n) = ~(E.lookup(V.mkvar(SN.mkstr n),!fenv))
		    handle E.Unbound v =>
			(Lib.inc fcount;
			 fenv := E.bind(v,~(!fcount),!fenv);
			 (!fcount))
	    in
		map (fn (n,m)=>(N.mkname(SN.mkstr n,idx n),N.mkname(SN.mkstr m,idx m))) nl
	    end

	(* post-parsing fun SF -> F *)
	fun bruijn_formula(f,fenv) =
	    (* fenv is a free name environment *)
	    let val fcount = if E.isempty (!fenv) then ref ~1
			     else ref(~(Lib.max (op >=)
					(map (fn v => E.lookup(v,!fenv))
					 (E.getvars (!fenv)))))
		fun nidx (n,(e,_)) = 
		    E.lookup(V.mkvar(SN.mkstr n),!fenv)
		    handle E.Unbound v => (* new free name *)
			(Lib.inc fcount;
			 fenv := E.bind(v,~(!fcount),!fenv);
			 ~(!fcount))
		and nbind (n,v,(e,f)) = (E.bind(V.mkvar(SN.mkstr n),v,e),f)
		fun pidx (n,(_,f)) = 
		    let val (i,_) = E.lookup(V.mkvar(SP.mkstr n),f)
		    in i end
		and parglen (n,(_,f)) =
		    let val (_,l) = E.lookup(V.mkvar(SP.mkstr n),f)
		    in l end
		and pbind (n,(v,na),(e,f)) =
		    (e,E.bind(V.mkvar(SP.mkstr n),(v,na),f))

		fun bbruin_formula(SF.True,n,m,e) = F.mk_true
		  | bbruin_formula(SF.False,n,m,e) = F.mk_false
		  | bbruin_formula(SF.IsEq(a,b),n,m,e) =
					 (F.mk_eq (bbruin_name(n,e) a) (bbruin_name(n,e) b))
		  | bbruin_formula(SF.IsNeq(a,b),n,m,e) =
		    (F.mk_ineq (bbruin_name(n,e) a) (bbruin_name(n,e) b))
		  | bbruin_formula(SF.And(l,r),n,m,e) =
		    (F.mk_and (bbruin_formula(l,n,m,e)) (bbruin_formula(r,n,m,e)))
		  | bbruin_formula(SF.Or(l,r),n,m,e) =
		    (F.mk_or (bbruin_formula(l,n,m,e)) (bbruin_formula(r,n,m,e)))

		  | bbruin_formula(SF.Diamond(a,f),lvl,m,env) =
		    (F.mk_diamond (bbruin_act(a,lvl,env)) (bbruin_formula(f,lvl,m,env)))
		  | bbruin_formula(SF.Box(a,f),n,m,e) =
		    (F.mk_box (bbruin_act(a,n,e)) (bbruin_formula(f,n,m,e)))
		  | bbruin_formula(SF.RootedVar(p,nl),n,m,e) =
		    (if parglen(p,e) <> length nl then
			raise PostParse ("argument lists don't match: "^(SF.mkstr f))
		    else ();
		     F.mk_rooted_var (bbruin_pvar (p,m,e)) (map (bbruin_name(n,e)) nl))

		  | bbruin_formula(rf as SF.RootedGFP(p,fl,f,al),n,m,e) =
		    (* hmmm... *)
		    let val m' = m+1
			val e' = pbind(p,(m',length fl),(mkbound e 0 fl))
			val l' = n+(length fl)
		    in
			if length fl <> length al then
			    raise PostParse ("argument lists don't match: "^(SF.mkstr rf))
			else ();
			if Lib.exists (fn n=> not(Lib.member SN.eq (n,fl)))
			    (Lib.sort SN.le (SF.free_names f)) then
			     raise PostParse ("fixpoint formula must be closed: "^(SF.mkstr rf))
			else ();
			(F.mk_rooted_gfp (bbruin_pvar(p,m',e'))
			 (map (bbruin_name (l',e')) fl)
			 (bbruin_formula(f,l',m',e'))
			 (map (bbruin_name (n,e)) al))
		    end
		  | bbruin_formula(rf as SF.RootedLFP(p,fl,f,al),n,m,e) =
		    let val m' = m+1
			val e' = pbind(p,(m',length fl),(mkbound e 0 fl))
			val l' = n+(length fl)
		    in
			if length fl <> length al then
			    raise PostParse ("argument lists don't match: "^(SF.mkstr rf))
			else ();
			if Lib.exists (fn n=> not(Lib.member SN.eq (n,fl)))
			    (Lib.sort SN.le (SF.free_names f)) then
			     raise PostParse ("fixpoint formula must be closed: "^(SF.mkstr rf))
			else ();
			(F.mk_rooted_lfp (bbruin_pvar (p,m',e'))
			 (map (bbruin_name (l',e')) fl)
			 (bbruin_formula(f,l',m',e'))
			 (map (bbruin_name (n,e)) al))
		    end
		  | bbruin_formula(SF.Sigma(a,f),n,m,e) =
		    (F.mk_sigma (bbruin_name (n,e) a) (bbruin_formula(f,n,m,e)))
		  | bbruin_formula(SF.BSigma(a,f),n,m,e) =
		    (F.mk_bsigma (bbruin_name (n,e) a) (bbruin_formula(f,n,m,e)))
		  | bbruin_formula(SF.Pi(a,f),n,m,e) =
		    (F.mk_pi (bbruin_name (n,e) a) (bbruin_formula(f,n,m,e)))
		  | bbruin_formula(SF.Exists(a,f),n,m,e) =
		    (F.mk_exists (bbruin_name (n,e) a) (bbruin_formula(f,n,m,e)))
		  | bbruin_formula(SF.Not(f),n,m,e) =
		    (F.mk_not (bbruin_formula(f,n,m,e)))

		and mkbound e i ([]) = e
		  | mkbound e i (n::r) =
		    mkbound (nbind (n,i,e)) (i+1) r
		and bbruin_name(lvl,env) n =
		    N.mkname(SN.mkstr n,(*lvl*)0-nidx(n,env))
		and bbruin_pvar(p,lvl,env) =
		    PV.mk_propvar(lvl-pidx(p,env))
		and bbruin_act(act,lvl,e) =
		    case act of
			SAct.Tau => Act.mk_tau()
		      | SAct.Input(n) =>
			    Act.mk_input(bbruin_name(lvl,e) n)
		      | SAct.Output(n) =>
			    Act.mk_output(bbruin_name(lvl,e) n)
	    in
		bbruin_formula(f,0,0,(E.empty,E.empty))
	    end
(* **** *)
	    
fun pbruijn_formula(f,fenv) =
	    (* fenv is a free name environment *)
	    let val fcount = if E.isempty (!fenv) then ref ~1
			     else ref(~(Lib.max (op >=)
				      (map (fn v => E.lookup(v,!fenv))
				       (E.getvars (!fenv)))))
		fun nidx (n,(e,_)) = 
		    E.lookup(V.mkvar(SN.mkstr n),!fenv)
		    handle E.Unbound v => (* new free name *)
			(Lib.inc fcount;
			 fenv := E.bind(v,~(!fcount),!fenv);
			 ~(!fcount))
		and nbind (n,v,(e,f)) = (E.bind(V.mkvar(SN.mkstr n),v,e),f)
		fun pidx (n,(_,f)) = 
		    let val (i,_) = E.lookup(V.mkvar(SP.mkstr n),f)
		    in i end
		and parglen (n,(_,f)) =
		    let val (_,l) = E.lookup(V.mkvar(SP.mkstr n),f)
		    in l end
		and pbind (n,(v,na),(e,f)) =
		    (e,E.bind(V.mkvar(SP.mkstr n),(v,na),f))

		fun Pbruin_formula(SF.True,n,m,e) = PF.mk_true
		  | Pbruin_formula(SF.False,n,m,e) = PF.mk_false
		  | Pbruin_formula(SF.IsEq(a,b),n,m,e) =
					 (PF.mk_eq (Pbruin_name(n,e) a) (Pbruin_name(n,e) b))
		  | Pbruin_formula(SF.IsNeq(a,b),n,m,e) =
		    (PF.mk_ineq (Pbruin_name(n,e) a) (Pbruin_name(n,e) b))
		  | Pbruin_formula(SF.And(l,r),n,m,e) =
		    (PF.mk_and (Pbruin_formula(l,n,m,e)) (Pbruin_formula(r,n,m,e)))
		  | Pbruin_formula(SF.Or(l,r),n,m,e) =
		    (PF.mk_or (Pbruin_formula(l,n,m,e)) (Pbruin_formula(r,n,m,e)))

		  | Pbruin_formula(SF.Diamond(a,f),lvl,m,env) =
		    (PF.mk_diamond (Pbruin_act(a,lvl,env)) (Pbruin_formula(f,lvl,m,env)))
		  | Pbruin_formula(SF.Box(a,f),n,m,e) =
		    (PF.mk_box (Pbruin_act(a,n,e)) (Pbruin_formula(f,n,m,e)))
		  | Pbruin_formula(SF.RootedVar(p,nl),n,m,e) =
		    (if parglen(p,e) <> length nl then
			raise PostParse ("argument lists don't match: "^(SF.mkstr f))
		    else ();
		     PF.mk_rooted_var (Pbruin_pvar (p,m,e)) (map (Pbruin_name(n,e)) nl))

		  | Pbruin_formula(rf as SF.RootedGFP(p,fl,f,al),n,m,e) =
		    
		    let val m' = m+1
			val e' = pbind(p,(m',length fl),(Pmkbound e 0 fl))
			val l' = n+(length fl)
		    in
			if length fl <> length al then
			    raise PostParse ("argument lists don't match: "^(SF.mkstr rf))
			else ();
			if Lib.exists (fn n=> not(Lib.member SN.eq (n,fl)))
			    (Lib.sort SN.le (SF.free_names f)) then
			     raise PostParse ("fixpoint formula must be closed: "^(SF.mkstr rf))
			else ();
			(PF.mk_rooted_gfp (Pbruin_pvar(p,m',e'))
			 (map (Pbruin_name (l',e')) fl)
			 (Pbruin_formula(f,l',m',e'))
			 (map (Pbruin_name (n,e)) al))
		    end
		  | Pbruin_formula(rf as SF.RootedLFP(p,fl,f,al),n,m,e) =
		    let val m' = m+1
			val e' = pbind(p,(m',length fl),(Pmkbound e 0 fl))
			val l' = n+(length fl)
		    in
			if length fl <> length al then
			    raise PostParse ("argument lists don't match: "^(SF.mkstr rf))
			else ();
			if Lib.exists (fn n=> not(Lib.member SN.eq (n,fl)))
			    (Lib.sort SN.le (SF.free_names f)) then
			     raise PostParse ("fixpoint formula must be closed: "^(SF.mkstr rf))
			else ();
			(PF.mk_rooted_lfp (Pbruin_pvar (p,m',e'))
			 (map (Pbruin_name (l',e')) fl)
			 (Pbruin_formula(f,l',m',e'))
			 (map (Pbruin_name (n,e)) al))
		    end
		  | Pbruin_formula(SF.Sigma(a,f),n,m,e) =
		    (PF.mk_sigma (Pbruin_name (n,e) a) (Pbruin_formula(f,n,m,e)))
		  | Pbruin_formula(SF.BSigma(a,f),n,m,e) =
		    (PF.mk_bsigma (Pbruin_name (n,e) a) (Pbruin_formula(f,n,m,e)))
		  | Pbruin_formula(SF.Pi(a,f),n,m,e) =
		    (PF.mk_pi (Pbruin_name (n,e) a) (Pbruin_formula(f,n,m,e)))
		  | Pbruin_formula(SF.Exists(a,f),n,m,e) =
		    (PF.mk_exists (Pbruin_name (n,e) a) (Pbruin_formula(f,n,m,e)))

		and Pmkbound e i ([]) = e
		  | Pmkbound e i (n::r) =
		    Pmkbound (nbind (n,i,e)) (i+1) r
		and Pbruin_name(lvl,env) n =
		    N.mkname(SN.mkstr n,(*lvl*)0-nidx(n,env))
		and Pbruin_pvar(p,lvl,env) =
		    PV.mk_propvar(lvl-pidx(p,env))
		and Pbruin_act(act,lvl,e) =
		    case act of
			SAct.Tau => Act.mk_tau()
		      | SAct.Input(n) =>
			    Act.mk_input(Pbruin_name(lvl,e) n)
		      | SAct.Output(n) =>
			    Act.mk_output(Pbruin_name(lvl,e) n)
	    in
		Pbruin_formula(f,0,0,(E.empty,E.empty))
	    end
(* ###############################*)
	fun parse_agent_raw (str) =
	    let val eof = ref false
		val lexer = PIParser.makeLexer (fn _ => if not (!eof)
							    then (eof := true;
								  str)
							else "") (ref 0,ref 0)
		val agtlexer = PIParser.Stream.cons(PILrVals.Tokens.DummyAGENT(0,0),lexer)
		val print_error = fn (s,i:int,_) =>
		    TextIO.print("Error, line " ^
			   (Lib.mkstrint i) ^ ", " ^ s ^ "\n")
		val result = PIParser.parse(15,agtlexer,print_error,())
	    in
		case result of
		    (Cmd.ParseAGENT(a),_) => a
		  | _ => raise Lib.disaster("no parse")
	    end
	and parse_agent(str) =
	    bbruin_agent(parse_agent_raw str,ref E.empty)

	fun parse_formula_raw (str) =
	    let val eof = ref false
		val lexer = PIParser.makeLexer (fn _ => if not (!eof)
							    then (eof := true;
								  str)
							else "") (ref 0,ref 0)
		val formlexer = PIParser.Stream.cons(PILrVals.Tokens.DummyFORMULA(0,0),lexer)
		val print_error = fn (s,i:int,_) =>
		    TextIO.print("Error, line " ^
			   (Lib.mkstrint i) ^ ", " ^ s ^ "\n")
		val result = PIParser.parse(15,formlexer,print_error,())
	    in
		case result of
		    (Cmd.ParseFORMULA(f),_) => f
		  | _ => raise Lib.disaster("no parse")
	    end
	and parse_formula(str) =
	    bruijn_formula(parse_formula_raw str,ref E.empty)

	fun yes_or_no_p() =
	    let val _ = print "(yes or no) "
		val line = read_line()
	    in
		if line <= "yes" andalso "yes" <= line then true
		else if line <= "no" andalso "no" <= line then false
		     else yes_or_no_p()
	    end
	and y_or_n_p () =
	    let val _ = print "(y or n) "
		val line = read_line()
	    in
		if line <= "y" andalso "y" <= line then true
		else if line <= "n" andalso "n" <= line then false
		     else y_or_n_p()
	    end

	fun addenv ((Id,defn), env) =
	    let val forgot = A.free_names(defn)
		fun pp [] = "??"
		  | pp [x] = pname(x)
		  | pp [a,b] = (pname a)^" and "^(pname b)
		  | pp (h::t) =
		    (pname h)^", "^(pp t)
		and pname n = 
		    let val s=(N.pretty_name n)
		    in
			if size s > 0 then s
			else (N.mkstr n)
		    end
		and plural(1) = ""
		  | plural _ = "s"
	    in
		if Lib.isnil(forgot) then
		    E.bind (V.mkvar Id, defn, env)
		else
		    (print ("Error: Definition of "^Id^" has free name"^(plural (length forgot))^" "^(pp forgot)^"\n");
		     env)
	    end

	and rmenv (str,env) =
	    E.unbind((V.mkvar str),env)

	and printagent(id,env) = 
	    let val agt = E.lookup(id,env)
	    in
		print("agent "^(V.mkstr id)^" = "
		      ^(SoA.mkstr(agt))^"\n")
	    end
	and printenv(env) =
	    if E.isempty(env) then () (*print "The environment is empty.\n"*)
	    else
		app (fn (id) => printagent(id,env)) (E.getvars env)

	and fprintagent(id,env) = 
	    let val (agt,args) = E.lookup(id,env)
	    in
		print("fagent "^(V.mkstr id)^"("^(Lib.mapconcat SN.mkstr args ",")^") = "
		      ^(SFA.mkstr(agt))^"\n")
	    end
	and fprintagentb(id,env) = 
	    let val (agt,args:int) = E.lookup(id,env)
	    in
		print("fagent "^(V.mkstr id)^"/"^(Lib.mkstrint args)^" = "
		      ^(FA.mkstr(agt))^"\n")
	    end
	and fprintenv(env) =
	    if E.isempty(env) then () (*print "The fusion environment is empty.\n"*)
	    else
		app (fn (id) => fprintagent(id,env)) (E.getvars env)
	and fprintenvb(env) =
	    if E.isempty(env) then () (*print "The fusion environment is empty.\n"*)
	    else
		app (fn (id) => fprintagentb(id,env)) (E.getvars env)

	and makstr_top(P) =
	    let val f = (A.free_names P)
		val fl = (N.fill(Lib.del_dups N.eq f))
		val nl = Lib.fold (fn (n,l) => nl_add(n,l)) (Lib.sort N.le fl) []
	    in
		A.makstr(P,nl)
	    end
	and makstr_d_top(D) =
	    let val f = (FCond.names D)
		val fl = (N.fill(Lib.del_dups N.eq f))
		val nl = Lib.fold (fn (n,l) => nl_add(n,l)) (Lib.sort N.le fl) []
	    in
		FCond.makstr(D,nl)
	    end
	and makstr_triple frn (P,Q,C) =
	    let val f = frn@(A.free_names P)@(A.free_names Q)@(FCond.names C)
		val fl = (N.fill(Lib.del_dups N.eq f))
		val nl = Lib.fold (fn (n,l) => nl_add(n,l)) (Lib.sort N.le fl) []
		val ps = A.makstr(P,nl)
		val qs = A.makstr(Q,nl)
		val cs = FCond.makstr(C,nl)
	    in
		("< "^ps
		 ^(if size ps > 15  then ",\n  " else ", ")
		 ^qs
		 ^(if size qs > 15  then ",\n  " else ", ")^cs^" >\n")
	    end
	and nl_add (n,l) =
	    let val s = N.pretty_name(n)
		val i = length l
	    in
		if size s > 0 andalso not(Lib.member (op =) (s,l)) then
		    s::l
		else ("~v"^(Lib.mkstrint i))::l
	    end
	and makstr_icomm_top sfun (C as O.Comm(c,a,p)) =
	    let val f = (A.free_names p)@(FCond.names c)@(Act.names a)
		val fl = (N.fill(Lib.del_dups N.eq f))
		val nl = Lib.fold (fn (n,l) => nl_add(n,l)) (Lib.sort N.le fl) []
	    in
		sfun (C,nl)
	    end
	val makstr_wcomm_top = makstr_icomm_top O.cw_makstr
	val makstr_comm_top = makstr_icomm_top O.c_makstr

	fun fmakstr_comm_top frn (C as Fsem.Comm(c,a,p)) =
	    let val f = SL.sort N.le true (frn@(FA.free_names p)@(FCond.names c)@(FAct.names a))
		val fl = rev (N.fill f)
		val nl = Lib.fold (fn (n,l) => nl_add(n,l)) fl []
		val _ = if !Flags.tracelevel>2 then
		    Lib.dprint(0,"fm_c_t: "^(Lib.mapconcat N.mkstr f ",")^" => "^(Lib.mapconcat N.mkstr fl ",")^" => "^(Lib.mapconcat (fn x=>x) nl ",")) else ()
	    in
		Fsem.c_makstr(C,nl)
	    end
	and fwmakstr_comm_top frn (C as Fsem.Comm(c,a,p)) =
	    let val f = SL.sort N.le true (frn@(FA.free_names p)@(FCond.names c)@(FAct.names a))
		val fl = rev (N.fill f)
		val nl = Lib.fold (fn (n,l) => nl_add(n,l)) fl []
	    in
		Fsem.cw_makstr(C,nl)
	    end
	and fmakstr_pair frn (P,Q) =
	    let val f = SL.sort N.le true (frn@(FA.free_names P)@(FA.free_names Q))
		val fl = rev (N.fill f)
		val nl = Lib.fold (fn (n,l) => nl_add(n,l)) fl []
	    in
		"< "^(FA.makstr (P,nl))^",\n  "^(FA.makstr (Q,nl))^" >\n"
	    end
	and fmakstr_top(P) =
	    let val f = (FA.free_names P)
		val fl = (N.fill(Lib.del_dups N.eq f))
		val nl = Lib.fold (fn (n,l) => nl_add(n,l)) (Lib.sort N.le fl) []
	    in
		FA.makstr(P,nl)
	    end

	fun doeq bisim (ag1,ag2,env,c) =
	    let val frn = Lib.del_dups N.eq ((A.free_names(ag1))@(A.free_names(ag2)))
		val eq = bisim(ag1, ag2, env,c)
		fun ppair (p,q,d) =
		    if (* true orelse *) !Flags.tracelevel > 1 then
			print ("< "^(A.mkstr p)^",\n  "^(A.mkstr q)^" > "^(FCond.mkstr d)^"\n")
		    else
			print (makstr_triple frn (p,q,d))
		val eqlen = length eq
	    in
		if eqlen = 0 then print "The two agents are NOT equal.\n"
		else (print ("The two agents are equal.\n"^
			     "Bisimulation relation size = "^(Lib.mkstrint eqlen)^".\n");
		      if eqlen > 1 andalso !Flags.interactive andalso Flags.trace()
			  andalso (print "Do you want to see it? ";
				   y_or_n_p())
			  then (print "R = \n";
				app ppair eq;
				if eqlen > 3
				    then print ("(that's length "^(Lib.mkstrint eqlen)^")\n")
				else ())
		      else ())
	    end
	handle (E.Unbound v) => print ("The identifier " ^ (V.mkstr v) ^ 
				       " is unbound\n")

	fun doeqd bisim cons (ag1,ag2,env) =
	    let val f = Lib.del_dups N.eq ((A.free_names(ag1))@(A.free_names(ag2)))
		fun dist ([],_) = FCond.True
		  | dist ((h::t),f) =
		    FCond.join((Lib.fold (fn (y,l)=>
				      if N.eq(h,y) then l
				      else
					  FCond.join(FCond.mismatch(h,y),l))
				f FCond.True),
			       dist (t,f))
		val m = dist (cons,f)
	    in
		doeq bisim (ag1,ag2,env,m)
	    end

	fun oeq(p,q,e) = doeq O.bisimulation (p,q,e,FCond.True)
	fun woeq(p,q,e) = doeq O.weakbisimulation (p,q,e,FCond.True)
	val oeqd = doeqd O.bisimulation 
	val woeqd = doeqd O.weakbisimulation

	fun fdoeq bisim (ag1,ag2,env) =
	    let val eq = bisim(ag1, ag2, env)
		val frn = (FA.free_names(ag1))@(FA.free_names(ag2))
		fun ppair (p,q) =
		    print (fmakstr_pair frn (p,q))
		val eqlen = length eq
	    in
		if eqlen = 0 then print "The two agents are NOT equal.\n"
		else (print ("The two agents are equal.\n"^
			     "Bisimulation relation size = "^(Lib.mkstrint eqlen)^".\n");
		      if !Flags.interactive andalso Flags.trace()
			  andalso (print "Do you want to see it? ";
				   y_or_n_p())
			  then (print "R = \n";
				app ppair eq;
				if eqlen > 3
				    then print ("(that's length "^(Lib.mkstrint eqlen)^")\n")
				else ())
		      else ())
	    end
	handle (E.Unbound v) => print ("The identifier " ^ (V.mkstr v) ^ 
				       " is unbound\n")

	val feq = fdoeq Fsem.bisimulation
	val fweq = fdoeq Fsem.weakbisimulation


	fun cfdoeq bisim (ag1,ag2,env) =
	    let val eq = bisim(ag1, ag2, env,FCond.True)
		val frn = (FA.free_names(ag1))@(FA.free_names(ag2))
		val eqlen = length eq
		fun fmakstr_triple frn (P,Q,C) =
		    let val f = SL.sort N.le true (frn@(FA.free_names P)@(FA.free_names Q)@(FCond.names C))
			val fl = rev (N.fill f)
			val nl = Lib.fold (fn (n,l) => nl_add(n,l)) fl []
			val ps = FA.makstr (P,nl)
			val qs = FA.makstr (Q,nl)
			val cs = FCond.makstr(C,nl)
			val _ = if !Flags.tracelevel>2 then
			    Lib.dprint(0,"fm_tr: "^(Lib.mapconcat N.mkstr f ",")^" => "^(Lib.mapconcat N.mkstr fl ",")^" => "^(Lib.mapconcat (fn x=>x) nl ",")) else ()
		    in
			"< "
			^ps^(if size ps > 15 then ",\n  " else ", ")
			^qs^(if size qs > 15 then ",\n  " else ", ")
			^cs^" >\n"
		    end
		fun ppair (p,q,c) =
		    print (fmakstr_triple frn (p,q,c))

	    in
		if eqlen = 0 then print "The two agents are NOT equal.\n"
		else (print ("The two agents are equal.\n"^
			     "Bisimulation relation size = "^(Lib.mkstrint eqlen)^".\n");
		      if eqlen > 1 andalso !Flags.interactive andalso Flags.trace()
			  andalso (print "Do you want to see it? ";
				   y_or_n_p())
			  then (print "R = \n";
				app ppair eq;
				if eqlen > 3
				    then print ("(that's length "^(Lib.mkstrint eqlen)^")\n")
				else ())
		      else ())
	    end
	handle (E.Unbound v) => print ("The identifier " ^ (V.mkstr v) ^ 
				       " is unbound\n")

	val cfeq = cfdoeq Fsem.cbisimulation
	val cfweq = cfdoeq Fsem.cweakbisimulation

        fun ftrans(ag,defs) =
	    let val trns = Fsem.ccommitments FCond.True (ag,defs)
		val f = FA.free_names ag
		fun ptrans(c) =
		    (if !Flags.tracelevel>0 then
			print ((Fsem.c_mkstr c)^"\n") else ()
		    ;
			print ((fmakstr_comm_top f c)^"\n")
			)
	    in
		if null(trns) then
		    print "NO commitments.\n"
		else
		    (print "Commitments:\n";
		     app ptrans trns;
		     if (length trns) > 5 then
			 print ("(that's "^(Lib.mkstrint (length trns))^" commitments)\n")
		     else ()
			 )
	    end
        fun fwtrans(ag,defs) =
	    let val trns = Fsem.cweakcomm FCond.True (ag,defs)
		val f = FA.free_names ag
		fun ptrans(c) =
		    if !Flags.tracelevel>0 then
			print ((Fsem.cw_mkstr c)^"\n")
		    else
			print ((fwmakstr_comm_top f c)^"\n")
	    in
		if null(trns) then
		    print "NO weak commitments.\n"
		else
		    (print "Weak commitments:\n";
		     app ptrans trns;
		     if (length trns) > 5 then
			 print ("(that's "^(Lib.mkstrint (length trns))^" commitments)\n")
		     else ()
			 )
	    end

        fun trans(ag,defs) =
	    let val trns = O.commitments FCond.True (ag,defs)
		fun ptrans(tr) =
		    print ((makstr_comm_top tr)^"\n")
	    in
		if null(trns) then
		    print "NO commitments.\n"
		else
		    (print "Commitments:\n";
		     app ptrans trns;
		     if (length trns) > 5 then
			 print ("(that's "^(Lib.mkstrint (length trns))^" commitments)\n")
		     else ()
			 )
	    end

        fun wtrans(ag,defs) =
	    let val trns = O.weakcomm FCond.True (ag,defs)
		fun ptrans(com) =
		    print ((makstr_wcomm_top com)^"\n");
	    in
		if null(trns) then
		    print "NO commitments.\n"
		else
		    (print "Weak commitments:\n";
		     app ptrans trns;
		     if (length trns) > 5 then
			 print ("(that's "^(Lib.mkstrint (length trns))^" commitments)\n")
		     else ())
	    end

	fun pobses(ag,defs) =
	    print("NYI\n")

(**)
	fun zpobses(ag,defs) =
	    let fun add(x,y) = (H.puthash(x,true,y); y)
		fun member(x,y) = case H.gethash(x,y) of NONE => false | SOME z => z
		val vis = H.maketable(3,
				      (fn (c,p)=>A.hashval p),
				      (fn ((c1,p1),(c2,p2))=>
				       FCond.implies(c1,c2) andalso 
				       A.ceq c2 (p1,p2)),
				      (FCond.True,A.mk_nil()),true)
		fun mks(c,a) =
		    let val f = (FCond.names c)@(Act.names a)
			val fl = (N.fill(Lib.del_dups N.eq f))
			val nl = Lib.fold (fn (n,l) => nl_add(n,l)) (Lib.sort N.le fl) []
		    in
			(if FCond.eq(c,FCond.True) then ""
			 else (FCond.makstr (c,nl)))^(Act.makstr(a,nl))
		    end
		fun pobs([],p,termp) =
		    print ("-> "^(makstr_top p)^
			   (if termp then "\n"
			    else "->...\n"))
		  | pobs(O.Comm(m,a,t)::tr,p,termp) =
		    (print ("-"^(mks(m,a)));
		     pobs(tr,p,termp))			
		    
		fun traverse c (p,trace) =
		    if A.is_process(p,defs) then
			let val cm = O.commitments c (p,defs)
			in
			    if null cm then pobs(rev trace,p,true)
			    else if member((c,p),vis) then pobs (rev trace,p,false)
			    else
				(add((c,p),vis);
				 app (fn (tt as O.Comm(m,_,t)) =>
				      traverse (FCond.join(c,m)) (t,tt::trace))
				 cm)
			end
		    else if A.is_abstraction(p,defs) then
			let val (vp,t') = A.abs_all(p,defs)
			    val nns = N.n_newNamesNotin(vp,(A.free_names p)@(FCond.names c))
			    val tt = A.beta_reduce t' (nns,0)
			in traverse c (tt,trace)
			end
		    else (* if A.is_concretion(p,defs) *)
			let val (np,vp,t') = A.conc_all(p,defs)
			    val f = A.free_names(p)
			    val nns = N.n_newNamesNotin(np,f@(FCond.names c))
			    val c' =
				Lib.fold (fn (nn,c)=>
				      Lib.fold (fn (f,c)=>
					    FCond.join(FCond.mismatch(nn,f),
						       c))
				      f c)
				nns c
			     val tt =
				 if np = 0 then t'
				 else A.beta_reduce t' (nns,0)
			 in traverse c' (tt,trace)
			end
	    in
		traverse FCond.True (ag,[]);
		()
	    end

	fun gsize(ag,defs) =
	    let fun member(x,y) = (* Lib.member A.eq (x,y) *) case H.gethash(x,y) of NONE => false | SOME z => z
		fun add(x,y) = (* x::y *) (H.puthash(x,true,y); y)
		val vtbl = (* [] *) 
		    H.maketable(3,(fn (c,p)=>A.hashval p),
				(fn ((c1,p1),(c2,p2))=>
				 FCond.implies(c1,c2) andalso 
				 A.ceq c2 (p1,p2)),
				(FCond.True,A.mk_nil()),true)
		fun grsize c (p,vis) =
		    if member((c,p),vis) then (0,vis)
		    else if A.is_process(p,defs) then 
			let val tr = O.commitments c (p,defs)
			    val vlen = if Flags.trace() then H.entrycount vis (*length vis*) else 0
			in
			    (if vlen > 0 andalso vlen mod 100 = 0 then print ("current size "^(Lib.mkstrint vlen)^"\n"^(A.mkstr p)^"\n") else ();
			     Lib.fold (fn (O.Comm(m,a,t),(sum,rvis)) =>
				   if (Act.is_input(a) andalso A.is_abstraction(t,defs)) orelse
				       (Act.is_output(a) andalso A.is_concretion(t,defs)) orelse
				       (Act.is_tau(a) andalso A.is_process(t,defs)) then
				       let val (rsum, rrvis) =
					   grsize (FCond.join(c,m)) (t,rvis)
				       in
					   (rsum+sum,rrvis)
				       end
				   else (sum,rvis)) tr (1,add((c,p),vis)))
			end
		     else if A.is_abstraction(p,defs) then
			 let val (vp,t') = A.abs_all(p,defs)
			     val nns = N.n_newNamesNotin(vp,
							 (A.free_names p)@(FCond.names c))
			     val tt = A.beta_reduce t' (nns,0)
			 in grsize c (tt,add((c,p),vis))
			 end
		     else (* if A.is_concretion(p,defs) *)
			 let val (np,vp,t') = A.conc_all(p,defs)
			     val f = A.free_names p
			     val nns = N.n_newNamesNotin(np,f@(FCond.names c))
			     val c' =
				 Lib.fold (fn (nn,c)=>
				       Lib.fold (fn (f,c)=>
					     FCond.join(FCond.mismatch(nn,f),
							c))
				       f c)
				 nns c
			     val tt =
				 if np = 0 then t'
				 else A.beta_reduce t' (nns,0)
			 in grsize c' (tt,add((c,p),vis))
			 end
		val (s,_) = grsize FCond.True (ag,vtbl)
	    in
		if Flags.trace() then print ("*vtbl size (agents) = "^(Lib.mkstrint(H.entrycount vtbl))^"*\"states\" = "^(Lib.mkstrint s)^"\n") else ();
		s 
	    end

	fun fdead(ag,defs) =
	    let fun vmember(x,y) = (* Lib.member A.eq (x,y) *) case H.gethash(x,y) of NONE => false | SOME z => z
		fun vadd(x,y) = (* x::y *) (H.puthash(x,true,y); y)
		val vtbl = (* [] *)
		    H.maketable(3,(fn (c,p)=>A.hashval p),
				(fn ((c1,p1),(c2,p2))=>
				 FCond.implies(c1,c2) andalso 
				 A.ceq c2 (p1,p2)),
				(FCond.True,A.mk_nil()),true)
		fun commstr(O.Comm(m,a,p)) =
		    if FCond.eq(m,FCond.True) then "|>"^(Act.mkstr a)
		    else "|"^(FCond.mkstr m)^">"^(Act.mkstr a)
		fun dead c (p,vis,trace,b) =
		    if A.is_process(p,defs) then
			let val tr = O.commitments c (p,defs)
			in
			    if null tr then (print("Deadlock found in "^(makstr_top p)^"\n reachable by "^(Lib.mkstrint (length trace))^" commitments\n");
					     if Flags.trace() then
						 print (" "^(Lib.mapconcat commstr (rev trace) "")^"\n")
					     else ();
					     (vadd((c,p),vis),true))
			    else if vmember((c,p),vis) then (vis,b)
				 else 
				     Lib.fold (fn (tt as O.Comm(m,a,t),(rvis,bo)) =>
					   if (Act.is_input(a) andalso A.is_abstraction(t,defs)) orelse
					       (Act.is_output(a) andalso A.is_concretion(t,defs)) orelse
					       (Act.is_tau(a) andalso A.is_process(t,defs)) then
					       dead (FCond.join(c,m)) (t,rvis,tt::trace,b orelse bo)
					   else
					       (print("Sorting deadlock found in "^(makstr_top p)^"\n reachable by "^(Lib.mkstrint (length trace))^" commitments\n");
						if Flags.trace() then
						    print (" "^(Lib.mapconcat commstr (rev trace) "")^"\n") else ();
						(rvis,true))
						) tr (vadd((c,p),vis),b)
			end
		    else if A.is_abstraction(p,defs) then
			let val (x,p') = A.abs_all(p,defs)
			    val nns = N.n_newNamesNotin(x,(A.free_names p)@(FCond.names c))
			    val tt = A.beta_reduce p' (nns,0)
			in
			    dead c (tt,vis,trace,b)
			end
		    else (* if A.is_concretion(p,defs) then *)
			let val (n,x,p') = A.conc_all(p,defs)
			    val f = A.free_names p
			    val nns = N.n_newNamesNotin(n,f@(FCond.names c))
			    val c' =
				Lib.fold (fn (nn,c)=>
				      Lib.fold (fn (f,c)=>
					    FCond.join(FCond.mismatch(nn,f),
						       c))
				      f c)
				nns c
			    val tt = A.beta_reduce p' (nns,0)
			in
			    dead c' (tt,vis,trace,b)
			end
	    in
		let val (_,b) = dead FCond.True (ag,vtbl,[],false)
		in if b then ()
		   else print "No deadlocks found.\n"
		end
	    end

	fun ztep(ag,defs) =
	    let fun succ(O.Comm(c,a,p)) = p
		fun add(x,y) = (H.puthash(x,true,y); y)
		fun member(x,y) = case H.gethash(x,y) of NONE => false | SOME z => z
		val vtbl = H.maketable(3,A.hashval,A.eq,A.mk_nil(),true)
		fun nl_mak(nl,frn) = (Lib.mapconcat (fn n=>N.makstr(n,frn)) nl ",")
		and nl_string(n,nl) =
		    if size(N.pretty_name(n)) > 0 then
			N.pretty_name(n)
		    else
			"~v"^(Lib.mkstrint(length nl))
		(* take a list of names and insert them into a list of *)
		(* strings according to their codes *)			
		fun nl_update([],nl) = nl
		  | nl_update(n::nr,[]) = 
		    nl_update(nr,[nl_string (n,[])])
		  | nl_update(n::nr,nl) =
		    let fun nl_insert(s,i,[]) =
			    if i = 0 then [s]
			    else "V"::(nl_insert(s,i-1,[]))
			  | nl_insert (s,i,nl) =
			    if i = 0 then s::nl
			    else
				hd(nl)::nl_insert(s,i-1,tl(nl))
		    in
			if !Flags.tracelevel > 2 then print ("nl_update(["^(N.mkstr n)^","^(Lib.mapconcat N.mkstr nr ",")^"],["^(Lib.mapconcat (fn n=>n) nl ",")^"])\n") else ();
			nl_update(nr,nl_insert(nl_string(n,nl),N.code(n),nl))
		    end
		fun nfirst (0,_) = []
		  | nfirst (n,[]) = []
		  | nfirst (n,h::t) = h::(nfirst(n-1,t))
		fun c_makstr(O.Comm(c,a,p),frn) =
		    "|"^(if FCond.eq(c,FCond.True) then "" else (FCond.makstr(c,frn)))
		    ^">"^(Act.makstr(a,frn))^"."^(A.makstr (p,frn))
		fun ptrans frn (com,n) =
		    (print ((Lib.mkstrint n)^": "^(c_makstr (com,frn))^"\n");
		     n+1)
		fun makenum l = Lib.atoi l
		fun streq(a,b) = a <= b andalso b <= a
		fun onestep(a,frn) =
		    if A.is_process(a,defs) then
			let val tr = O.commitments FCond.True (a,defs)
			    val _ = if member(a,vtbl) then
				print("[Circular behaviour detected]\n")
				else (add(a,vtbl);())
			    val x =
				if null tr then
				    (print("No commitments for "^(A.makstr (a,frn))
					   ^"\nQuitting.\n");~1)
				else
				    Lib.fold (ptrans frn) (rev tr) 0
			    val line = if x >= 0 then (print "Step>";read_line()) else ""
			in
			    if null tr then ()
			    else
				if line <= "" andalso line >= "" then
				    onestep(succ (Lib.nth (tr,0)),frn)
				else if ord(String.sub (line,0)) >= (ord #"0") andalso ord(String.sub (line,0)) <= (ord #"9")
					 then let val n = makenum line
					      in
						  if n < (length tr) then
						      onestep(succ (Lib.nth (tr, n)),frn)
						  else (print("Max transition = "^(Lib.mkstrint ((length tr)-1)^"\n"));
							onestep(a,frn))
					      end
				else if streq(line,"q") orelse streq(line,"quit")
					 then ()
				     else (print "What?\n";
					   onestep(a,frn))
			end
		    else if A.is_concretion(a,defs) then
			let val (n,x,p') = A.conc_all(a,defs)
			    val nns = N.n_newNamesNotin(n,A.free_names a)
			    val mx = if null(A.free_names a) then ~1
				     else N.code(Lib.max N.le (A.free_names a))+1
			    (* insert nns in the (pruned) list frn *)
			    val nfrn = nl_update(Lib.sort N.le nns,nfirst(mx,frn))
			    val tt = A.beta_reduce p' (nns,0)
			in
			    print("Concretion (^"^(nl_mak (nns,nfrn)^")["^(nl_mak (x,nfrn))^"]\n"));
			    onestep(tt,nfrn)
			end
		    else (* if A.is_abstraction(a,defs) then *)
			let val (x,p') = A.abs_all(a,defs)
			    val nns = N.n_newNamesNotin(x,A.free_names a)
			    val mx = if null(A.free_names a) then ~1
				     else N.code(Lib.max N.le (A.free_names a))+1
			    val nfrn = nl_update(Lib.sort N.le nns,nfirst(mx,frn))
			    val tt = A.beta_reduce p' (nns,0)
			in
			    print("Abstraction (\\"^(nl_mak (nns,nfrn)^")\n"));
			    onestep(tt,nfrn)
			end
	    in
		(print ("* Valid responses are:\n"^
			"  a number N >= 0 to select the Nth commitment,\n"^
			"  <CR> to select commitment 0,\n"^
			"  q to quit.\n");
		 onestep(ag,
			 Lib.fold (fn (n,l) => nl_add(n,l))
			 (Lib.sort N.le
			  (N.fill(Lib.del_dups N.eq (A.free_names ag))))
			 []))
	    end


	fun step(ag,defs) =
	    let fun succ(O.Comm(c,a,p)) = p
		fun add(x,y) = (H.puthash(x,true,y); y)
		fun member(x,y) = case H.gethash(x,y) of NONE => false | SOME z => z
		val vtbl = H.maketable(3,A.hashval,A.eq,A.mk_nil(),true)
		fun nl_mak(nl,frn) = (Lib.mapconcat (fn n=>N.makstr(n,frn)) nl ",")
		and nl_string(n,nl) =
		    if size(N.pretty_name(n)) > 0 then
			N.pretty_name(n)
		    else
			"~v"^(Lib.mkstrint(length nl))
		(* take a list of names and insert them into a list of *)
		(* strings according to their codes *)			
		fun nl_update([],nl) = nl
		  | nl_update(n::nr,[]) = 
		    nl_update(nr,[nl_string (n,[])])
		  | nl_update(n::nr,nl) =
		    let fun nl_insert(s,i,[]) =
			    if i = 0 then [s]
			    else "BUG"::(nl_insert(s,i-1,[]))
			  | nl_insert (s,i,nl) =
			    if i = 0 then s::nl
			    else
				hd(nl)::nl_insert(s,i-1,tl(nl))
		    in
			if !Flags.tracelevel > 2 then print ("nl_update(["^(N.mkstr n)^","^(Lib.mapconcat N.mkstr nr ",")^"],["^(Lib.mapconcat (fn n=>n) nl ",")^"])\n") else ();
			nl_update(nr,nl_insert(nl_string(n,nl),N.code(n),nl))
		    end
		fun nfirst (0,_) = []
		  | nfirst (n,[]) = []
		  | nfirst (n,h::t) = h::(nfirst(n-1,t))
		fun c_makstr(O.Comm(c,a,p),frn) =
		    "|"^(if FCond.eq(c,FCond.True) then "" else (FCond.makstr(c,frn)))
		    ^">"^(Act.makstr(a,frn))^"."^(A.makstr (p,frn))
		fun ptrans frn (com,n) =
		    (print ((Lib.mkstrint n)^": "^(c_makstr (com,frn))^"\n");
		     n+1)
		fun makenum l = Lib.atoi l
		fun streq(a,b) = a <= b andalso b <= a
		fun onestep(a,frn) =
		    if A.is_process(a,defs) then
			let val tr = O.commitments FCond.True (a,defs)
			    val _ = if member(a,vtbl) then
				print("[Circular behaviour detected]\n")
				else (add(a,vtbl);())
			    val x =
				if null tr then
				    (print("No commitments for "^(A.makstr (a,frn))
					   ^"\nQuitting.\n");~1)
				else
				    Lib.fold (ptrans frn) (rev tr) 0
			    val line = if x >= 0 then (print "Step>";read_line()) else ""
			in
			    if null tr then ()
			    else
				if line <= "" andalso line >= "" then
				    onestep(succ (Lib.nth (tr,0)),frn)
				else if ord(String.sub (line,0)) >= (ord #"0") andalso ord(String.sub (line,0)) <= (ord #"9")
					 then let val n = makenum line
					      in
						  if n < (length tr) then
						      onestep(succ (Lib.nth (tr, n)),frn)
						  else (print("Max transition = "^(Lib.mkstrint ((length tr)-1)^"\n"));
							onestep(a,frn))
					      end
				else if streq(line,"q") orelse streq(line,"quit")
					 then ()
				     else (print "What?\n";
					   onestep(a,frn))
			end
		    else if A.is_concretion(a,defs) then
			let val (n,x,p') = A.conc_all(a,defs)
			    val nns = N.n_newNamesNotin(n,A.free_names a)
			    val mx = if null(A.free_names a) then ~1
				     else N.code(Lib.max N.le (A.free_names a))+1
			    (* insert nns in the (pruned) list frn *)
			    val nfrn = nl_update(Lib.sort N.le nns,nfirst(mx,frn))
			    val tt = A.beta_reduce p' (nns,0)
			in
			    print("Concretion (^"^(nl_mak (nns,nfrn)^")["^(nl_mak (x,nfrn))^"]\n"));
			    onestep(tt,nfrn)
			end
		    else (* if A.is_abstraction(a,defs) then *)
			let val (x,p') = A.abs_all(a,defs)
			    val nns = N.n_newNamesNotin(x,A.free_names a)
			    val mx = if null(A.free_names a) then ~1
				     else N.code(Lib.max N.le (A.free_names a))+1
			    val nfrn = nl_update(Lib.sort N.le nns,nfirst(mx,frn))
			    val tt = A.beta_reduce p' (nns,0)
			in
			    print("Abstraction (\\"^(nl_mak (nns,nfrn)^")\n"));
			    onestep(tt,nfrn)
			end
	    in
		(print ("* Valid responses are:\n"^
			"  a number N >= 0 to select the Nth commitment,\n"^
			"  <CR> to select commitment 0,\n"^
			"  q to quit.\n");
		 onestep(ag,
			 Lib.fold (fn (n,l) => nl_add(n,l))
			 (Lib.sort N.le
			  (N.fill(Lib.del_dups N.eq (A.free_names ag))))
			 []))
	    end

	fun cmdloop infun (env) =
	    let val lineNo = ref 0
		val pCount = ref 0
		fun mkcmdlexer inputfun =
		PIParser.Stream.cons(PILrVals.Tokens.DummyCMD(0,0),
				     PIParser.makeLexer inputfun (lineNo,pCount))
		fun eoftoken(lex) =
		let val (tok,nlex) = PIParser.Stream.get(lex)
		    val eoftok = PILrVals.Tokens.EOF(0,0)
		    val cmdtok = PILrVals.Tokens.DummyCMD(0,0)
		in
		    PIParser.sameToken(tok,eoftok)
		    orelse (PIParser.sameToken(tok,cmdtok)
			    andalso let val (tok,nlex) = PIParser.Stream.get(nlex)
				    in PIParser.sameToken(tok,eoftok) end)
		end
		fun parse () =
		let val lex = mkcmdlexer infun
		    val print_error = fn (s,i:int,j:int) =>
			TextIO.print(
			       "Error"^
			       (if !Flags.interactive andalso i=0 andalso j=0
				    then ""
			       else if i = j then
				   (" in line "^(Lib.mkstrint i))
			       else
				   (" in lines "^(Lib.mkstrint i)^"-"^(Lib.mkstrint j)))
			       ^": " ^ s ^ "\n")
		in
		    if !Flags.interactive then
			(print "MWB>";lineNo:=0;pCount:=0;Lib.dbglvl := 0)
		    else ();
		    if eoftoken(lex) then (Cmd.ParseCMD(Cmd.Quit),lex)
			else
			    PIParser.parse(if !Flags.interactive then 0 else 15,
					   lex,print_error,())
			    handle LrParser.ParseError => parse()
				 | PILex.LexError => (print "Lex error.\n";
						      parse())
		end

		fun cmdhandle(cmd,env as (benv,senv,fbenv,fsenv)) =
		    (case cmd of
			 Cmd.NULL =>
			     env
		       | Cmd.Help(c) =>
			     (print(help(c));
			      env)

		       | Cmd.Agent(id,agt) =>
			     (O.cleartbls(); A.cleartbls();
			      (addenv((id,bbruin_agent(agt,ref E.empty)),benv),
			       E.bind(V.mkvar id,postparse_to_sort agt,
				      senv),
			       fbenv,fsenv))
		       | Cmd.FAgent(id,args,agt) =>
			     (Fsem.cleartbls(); FA.cleartbls();
			      let val fenv = ref E.empty
				  val fnl = bbruin_nlist(args,fenv)
				  val free = (SL.minus (fn x=>x) SN.le
					      (SFA.free_names agt,SL.sort SN.le true args))
			      in
				  if null free then
				      (benv,senv,
				       E.bind(V.mkvar id,(bbruin_fagent(agt,fenv),length args),fbenv),
				       E.bind(V.mkvar id,(agt,args),fsenv))
				  else
				      (print("Error: Definition of agent "^id^" is not closed: "^(Lib.mapconcat SN.mkstr free ",")^(if (length free)=1 then " is" else " are")^" free\n");
				       env)
			      end)
			     
 			  | Cmd.Check(a,f) =>
				let val e = ref E.empty
				    val ba = bbruin_agent(a,e)
 				    val ns = (Lib.fold (fn (n,ns)=>NS.add_distinct n ns)
 					      (Lib.del_dups N.eq (A.free_names ba)) NS.init)
			  (* this doesn't work well *)
			  (* [BV 31-May-95] Well, it should now! *)
 				    val nba = ASS.normal_form ba ns benv
				    (* val nba = A.std_form(ba,benv) *)
				    val bf = bruijn_formula(f,e)
				in
				    MC.mccount := 0;
				    if Flags.trace() then
					print("nf: "^(A.mkstr nba)^"\n")
				    else ();
				    if MC.naked_model_checker nba bf benv then
					print("Yes!")
				    else
					print("No.");
				    print(" ("^(Lib.mkstrint (!MC.mccount))^" inference"^(if !MC.mccount <> 1 then "s" else "")^")\n");
				    env
				end
		       | Cmd.Prove(a,f) =>
			     let val e = ref E.empty
				 val ba = bbruin_agent(a,e)
				 val ns = (Lib.fold (fn (n,ns)=>NS.add_distinct n ns)
					   (Lib.del_dups N.eq (A.free_names ba)) NS.init)
				     
				 val nba = ASS.normal_form ba ns benv
				     
				 val bf = pbruijn_formula(f,e)
			     in
				 PROVER.mccount := 0;
				 if Flags.trace() then
				     print("nf: "^(A.mkstr nba)^"\n")
				 else ();
				     if PROVER.naked_prover nba bf benv  then
					 print("Model Prover says: YES!\n")
				     else
					 print("Model Prover says: NO.\n");
					 print(" ("^(Lib.mkstrint (!PROVER.mccount))^" inference"^(if !PROVER.mccount <> 1 then "s" else "")^")\n");
					 env
			     end
		       | Cmd.Clear(id) =>
			     (O.cleartbls(); A.cleartbls();
			      Fsem.cleartbls(); FA.cleartbls();
			      if id = "" then
				  (print "Clearing environment.\n";
				   (E.empty,E.empty,E.empty,E.empty))
			      else
				  (rmenv(id,benv),rmenv(id,senv),
				   rmenv(id,fbenv),rmenv(id,fsenv)))
		       | Cmd.Dead(a) =>
			     (fdead(A.std_form(bbruin_agent(a,ref E.empty),benv),benv);
			      env)
		       | Cmd.Environment(id) =>
			     (if id = "" then
				  (printenv(senv);
				   if !Flags.tracelevel > 1 then
				       fprintenvb(fbenv)
				   else
				       fprintenv(fsenv))
			      else
				  (printagent(V.mkvar id,senv)
				   handle E.Unbound v => ();
				       if !Flags.tracelevel>1 then
					   fprintagentb(V.mkvar id,fbenv)
				       else
					   fprintagent(V.mkvar id,fsenv)
					   handle E.Unbound v => ())
				  ;env)
		       | Cmd.Feq(a1,a2) =>
			     let val fenv = ref E.empty
				 val p1 = FA.std_form(bbruin_fagent(a1,fenv),fbenv)
				 val p2 = FA.std_form(bbruin_fagent(a2,fenv),fbenv)
				 val _ = if !Flags.tracelevel>2 then
				     Lib.dprint(0,"feq:\n "^(FA.mkstr p1)^
						" \n"^(FA.mkstr p2)^
						"\n"^
						(Lib.mapconcat (fn (i,v)=>i^"=> "^(Lib.mkstrint v))
						 (map (fn v => (V.mkstr v,E.lookup(v,!fenv)))
						  (E.getvars (!fenv))) "\n"))
					 else ()
			     in
				 cfeq(p1,p2,fbenv);
				 env
			     end
		       | Cmd.Fweq(a1,a2) =>
			     let val fenv = ref E.empty
				 val p1 = FA.std_form(bbruin_fagent(a1,fenv),fbenv)
				 val p2 = FA.std_form(bbruin_fagent(a2,fenv),fbenv)
			     in
				 cfweq(p1,p2,fbenv);
				 env
			     end
		       | Cmd.Eq(a1,a2) =>
			     let val fenv = ref E.empty
				 val p1 = A.std_form(bbruin_agent(a1,fenv),benv)
				 val p2 = A.std_form(bbruin_agent(a2,fenv),benv)
			     in
				 oeq(p1,p2,benv);
				 env
			     end
		       | Cmd.EqD(a1, a2, nl) =>
			     let val fenv = ref E.empty
				 val fnl = bbruin_nlist(nl,fenv)
				 val p1 = A.std_form(bbruin_agent(a1,fenv),benv)
				 val p2 = A.std_form(bbruin_agent(a2,fenv),benv)
			     in
				 oeqd fnl (p1,p2,benv);
				 env
			     end
		       | Cmd.Input(file) =>
			     let fun rfile file old =
				 let val s = TextIO.openIn(file)
				     val e' = cmdloop (fn _ => case TextIO.inputLine s of SOME x => x | NONE => "") env
				 in
				     (TextIO.closeIn s;
				      Flags.interactive := old;
				      e')
				 end
				 val oldi = !Flags.interactive
				 val _ = Flags.interactive := false
			     in
				 (rfile file oldi)
				 handle (IO.Io {name,function,cause,...}) =>
				     (print ("Error: "^name^"("^function^")\n"^(exnMessage cause)^"\n");
				      Flags.interactive := oldi;
				      env)
			     end

		       | Cmd.Size(a) =>
			     (print ((Lib.mkstrint (gsize(A.std_form(bbruin_agent(a,ref E.empty),benv), benv)))^"\n");
			      env)
		       | Cmd.Sort(a) =>
			     ((let val (sort,obsort) = SS.sort(postparse_to_sort a,senv,E.empty)
			       in
				   print("Object sort: "
					 ^(SS.ob_mkstr obsort)
					 ^"\nSorting:\n "
					 ^(SS.s_mkstr sort)^"\n");
				   env
			       end) handle SS.SortError s =>
				   (print ("Sorting error: "^s^"\n");
				    env))
		       | Cmd.Step(a) =>
			     (step(A.std_form(bbruin_agent(a,ref E.empty),benv),benv);
			      env)
		       | Cmd.Ztep(a) => 
			     (ztep(A.std_form(bbruin_agent(a,ref E.empty),benv),benv);
			      env)
		       | Cmd.FTransitions(a) =>
			     (ftrans(bbruin_fagent(a,ref E.empty),fbenv);
			      env)
		       | Cmd.FWTransitions(a) =>
			     (let val ba = bbruin_fagent(a,ref E.empty)
			      in
				  if !Flags.tracelevel>0 then
				      print ("For agent "^(FA.mkstr ba)^":\n")
				  else ();
				      fwtrans(ba,fbenv)
			      end;
			      env)
		       | Cmd.Transitions(a) =>
			     (trans(bbruin_agent(a,ref E.empty),benv);
			      env)
		       | Cmd.Verify(i,b,a,f) =>
			     let val _ = print("["^(Lib.mkstrint i))
				 val e = ref E.empty
				 val ba = bbruin_agent(a,e)
				 val ns = (Lib.fold (fn (n,ns)=>NS.add_distinct n ns)
					   (Lib.del_dups N.eq (A.free_names ba)) NS.init)
				 (* this doesn't work well *)
				 (* [BV 31-May-95] Well, it should now! *)
				 val nba = ASS.normal_form ba ns benv
				 (* val nba = A.std_form(ba,benv) *)
				 val bf = bruijn_formula(f,e)
			     in
				 TextIO.flushOut(TextIO.stdOut);
				 if Flags.trace() then
				     print("nf: "^(A.mkstr nba)^"\n")
				 else ();
				     if b = MC.naked_model_checker nba bf benv then
					 print("]")
				     else
					 print("]\nDisagreement:"^(Lib.mkstrint i)^"\n");
					 env
			     end
		       | Cmd.Wtransitions(a) =>
			     (wtrans(bbruin_agent(a,ref E.empty),benv);
			      env)
		       | Cmd.Weq(a1,a2) =>
			     let val fenv = ref E.empty
				 val p1 = A.std_form(bbruin_agent(a1,fenv),benv)
				 val p2 = A.std_form(bbruin_agent(a2,fenv),benv)
			     in
				 woeq(p1,p2,benv);
				 env
			     end
		       | Cmd.WeqD(p,q,nl) =>
			     let val fenv = ref E.empty
				 val fnl = bbruin_nlist(nl,fenv)
				 val a = A.std_form(bbruin_agent(p,fenv),benv)
				 val b = A.std_form(bbruin_agent(q,fenv),benv)
			     in
				 woeqd fnl (a,b,benv);
				 env
			     end
		       | Cmd.Quit =>
			     raise Quit env
		       | Cmd.Time(cmd) =>
			     let val oldi = !Flags.interactive
				 val _ = Flags.interactive := false
				 val start = Timer.startCPUTimer()
				 val rt0 = Timer.startRealTimer()
				 val env' = cmdhandle(cmd,env) handle (Quit e) => e
				 val rt = Timer.checkRealTimer(rt0)
			         val {gc,nongc} = Timer.checkCPUTimes(start)
				 val (usrtime,systime,gctime) =
				     (Time.+(#usr nongc,#usr gc),
				      Time.+(#sys nongc,#sys gc),
				      Time.+(#usr gc, #sys gc))
(* 				 val {usr=usrtime,sys=systime,gc=gctime} = Timer.checkCPUTimer(start) *)
				 val ohead =
				     Lib.timediff(rt, (Lib.fold Time.+ [usrtime,systime] gctime))
				 val _ = Flags.interactive := oldi
			     in
				 print("User CPU time elapsed: "^(Time.toString usrtime)^"\nSystem CPU time: "^(Time.toString systime)^"\nGC time: "^(Time.toString gctime)^"\nReal time elapsed: "^(Time.toString rt)^"\nOverhead: "^(Time.toString ohead)^"\n");
				 env'
			     end
		       | Cmd.Traces(ag) =>
			     (zpobses(bbruin_agent (ag,ref E.empty),benv);
			      env)
		       | Cmd.Set(setting) =>
			     (setit(setting); env)
		       | Cmd.Show(setting) =>
			     (showit(setting); env)

		       | _ => (print "NYI, I guess.\n";
			       env)
			     )

		fun loop (env) =
		    Lib.handleInterrupt
		    (fn () =>
		    let
			(* #### uncaught Bind when parser tries to be clever *)
			val result = parse()
		    in
			case result of
			    (Cmd.ParseCMD(cmd),_) =>
				((loop (cmdhandle(cmd,env)))
				 handle E.Unbound v =>
				     (print ("Unbound identifier: "^(V.mkstr v)^"\n");
				      loop env)
				      | PostParse s =>
					    (print (s^"\n");
					     loop env)
				      | Quit e => e)
			  | _ => (print("Parse error.  Try again.\n");
				  loop env)
		    end)
		handle Lib.Interrupt =>
		    (print "\n*Interrupt*\n";
		     Flags.interactive := true;
		     Lib.dbglvl := 0;
		     loop env)
		     | (F.NegationError(s,f)) =>
                           (print("Error: "^s^"\n in formula: "^
                                  (F.mkstr f)^"\n");
                            loop env)
		     | (A.SemanticsError(s,a)) =>
			   (print("Semantic Error:\n "^s^"\n in agent: "^
				  (makstr_top a)^"\n");
			    loop env)
		     | (FA.SemanticsError(s,a)) =>
			   (print("Semantic Error:\n "^s^"\n in agent: "^
				  (fmakstr_top a)^"\n");
			    loop env)

	    in
		loop env
	    end

	and toplevel(vrsn) =
	    let val om = SMLofNJ.Internals.GC.messages false
		val _ = version := vrsn
		val _ = Lib.dbglvl := 0
		val _ = (A.hashdepth := 2; FA.hashdepth := 2)
	    in
		Flags.interactive := true;
		print ("\n The Mobility Workbench\n"^
		       " ("^vrsn^")\n\n");
		cmdloop (fn _ => case TextIO.inputLine TextIO.stdIn of SOME x => x | NONE => "") (E.empty,E.empty,E.empty,E.empty);
		O.cleartbls(); A.cleartbls(); Fsem.cleartbls(); FA.cleartbls();
		(* This is documented as bool->bool, so arg shd b om here *)
(* 		SMLofNJ.Internals.GC.messages om; *)
		()
	    end
	handle (Lib.disaster str) =>
	    print ("Program error: "^str^
		   "\nPlease write to mwb-bugs@docs.uu.se about it.\n")
	     | exn =>
		   print("Program error: Uncaught exception "^(exnName exn)^
			 ": "^(exnMessage exn)^
			 "\nPlease write to mwb-bugs@docs.uu.se about it.\n")



	and help(Cmd.HelpC.NULL) =
	    "Commands are:\n"^
	    " pi: agent deadlocks eq eqd weq weqd size sort step transitions\n"^
	    " model checking: check prove\n"^
	    " fusion: fagent feq fweq ftransitions fwtransitions\n"^
	    " general: input env clear set show time help quit\n"^
	    "Type \"help CMD\" to get help on the command CMD.\n\n"^
	    "The syntax for agents is what you'd expect, plus that tau is t, nil is 0,\n"^
	    "(nu x) is (^x), input prefix is a(x), output is 'a<x>,\n"^
	    "(lambda x) is (\\x) and concretions are [x]\n"^
	    "\nFor fusion agents, free input prefix is a<x>, fusion is {a=b,c=d} or 1,\n"^
	    "and the match construct can take sequences: [a=x,b=y]P\n"
(* 	    "and the match construct can take sequences: [a=x,b=y,c#d]P\n" *)
	  | help(Cmd.HelpC.All) =
	    (app print (map help [Cmd.HelpC.Agent,Cmd.HelpC.Check,Cmd.HelpC.Clear,Cmd.HelpC.Dead,Cmd.HelpC.Env,
				 Cmd.HelpC.Eq,Cmd.HelpC.Eqd,Cmd.HelpC.Input,Cmd.HelpC.Step,
				 Cmd.HelpC.Size,Cmd.HelpC.Sort,Cmd.HelpC.Time,Cmd.HelpC.Trans,Cmd.HelpC.Wtrans,Cmd.HelpC.Weq,Cmd.HelpC.Weqd,
				 Cmd.HelpC.Set,Cmd.HelpC.Show,Cmd.HelpC.Quit,
				 Cmd.HelpC.FAgent,Cmd.HelpC.Feq,Cmd.HelpC.Fweq,Cmd.HelpC.FTransitions,Cmd.HelpC.FWTransitions]);
	     "")
	  | help(Cmd.HelpC.Agent) =
	    "agent P(x) = def\n"^
	    "agent P = abstr\n"^
            "           define the agent identifier P.  The definition must be closed.\n"
          | help(Cmd.HelpC.FAgent) =
            "fagent P(x,y,...) = def\n"^
            "           define the fusion agent identifier P.\n"^
            "           All free names of def must be in the arguments x,y,....\n"
          | help(Cmd.HelpC.Check) =
            "check A F          checks that the agent A is a model of the formula F.\n"
          | help(Cmd.HelpC.Prove) =
            "prove A F          proves that the agent A is a model of the formula F.\n"
          | help(Cmd.HelpC.Clear) =
            "clear P            removes the definition of agent identifier P\n"^
            "clear              removes ALL agent definitions\n"
          | help(Cmd.HelpC.Dead) =
            "deadlocks A        show deadlocks in the agent A\n"
          | help(Cmd.HelpC.Env) =
            "env P              shows the definition of agent or formula identifier P\n"^
            "env                shows ALL agent and formula definitions\n"
          | help(Cmd.HelpC.Eq) =
            "eq A B             check whether agents A and B are strong open equivalent\n"
          | help(Cmd.HelpC.Feq) =
            "feq A B            check whether fusion agents A and B are strong hyperequivalent\n"
          | help(Cmd.HelpC.Fweq) =
            "fweq A B   check whether fusion agents A and B are weak hyperequivalent\n"
          | help(Cmd.HelpC.Eqd) =
            "eqd (n,m,..,o) A B\n"^
            "           check whether agents A and B are strong open equivalent,\n"^
            "           given that (n,m,..,o) are distinct from all free names\n"^
            "           in A and B\n"
          | help(Cmd.HelpC.Input) =
            "input \"file\"     read commands from file\n"
          | help(Cmd.HelpC.Step) =
            "step P             simulate P step by step\n"
          | help(Cmd.HelpC.Size) =
            "size P             give a low estimate of the graph size of P\n"
          | help (Cmd.HelpC.Sort) =
            "sort A             show object sort and most general sorting of A\n"
          | help(Cmd.HelpC.Time) =
            "time CMD ...       execute the command CMD and print timing info\n"
          | help(Cmd.HelpC.Trans) =
            "transitions P      show the commitments of the agent P\n"
          | help(Cmd.HelpC.Wtrans) =
            "wtransitions P     show the weak commitments of the agent P\n"
          | help(Cmd.HelpC.FTransitions) =
            "ftransitions P     show the commitments of the fusion agent P\n"
          | help(Cmd.HelpC.FWTransitions) =
            "fwtransitions P    show the weak commitments of the fusion agent P\n"
          | help(Cmd.HelpC.Verify) =
            "verify I B A F     verify that the result of a CHECK A F command is B\n"^
            "                   I is the verify id.\n"
          | help(Cmd.HelpC.Weq) =
            "weq A B            check whether agents A and B are weak open equivalent\n"
          | help(Cmd.HelpC.Weqd) =
            "weqd (n,m,..,o) A B\n"^
            "           check whether agents A and B are weak open equivalent,\n"^
            "           given that (n,m,..,o) are distinct from all free names\n"^
            "in A and B\n"
          | help(Cmd.HelpC.Quit) =
            "quit               terminates MWB\n"
          | help(Cmd.HelpC.Set) =
            "set STTNG  set the setting STTNG. See \"set ?\"\n"
          | help(Cmd.HelpC.Show) =
            "show STTNG show the setting STTNG. See \"show ?\"\n"^
            "show               shows all settings\n"
          | help(_) =
            "Sorry, no specific help on that subject.\n"^(help Cmd.HelpC.NULL)

        and setit(Cmd.SetC.Debug(n)) =
            (Flags.tracelevel := n
             ;if n > 1 then
                 SMLofNJ.Internals.GC.messages true
             else if n = 0 then
                 SMLofNJ.Internals.GC.messages false
                  else ())
          | setit(Cmd.SetC.Threshold(f)) = 
            (if f > 100 orelse f <= 0 then
                 print ("Bogus threshold value; please use a value between 1 and 100.\n")
             else
                 (H.set_rehash_threshold(real(f)/100.0);
                  print("New rehash threshold = "^(Lib.mkstrint(floor(100.0*(H.get_rehash_threshold()))))^"\n")))
          | setit(Cmd.SetC.Hashdepth(n)) =
            if n > 0 then
                (A.hashdepth := n; FA.hashdepth := n)
            else print ("Bad hashdepth; please use a value greater than 0.\n")
          | setit(Cmd.SetC.Rewrite(b)) =
            (if b <> !Flags.rewrite then
                 (* forget old rewrites *)
                 (O.cleartbls(); Fsem.cleartbls())
             else ();
             Flags.rewrite := b; showit(Cmd.ShowC.Rewrite))
          | setit(Cmd.SetC.Remember(b)) =
            (O.enabletbls(b); A.enabletbls(b);
             Fsem.enabletbls(b); FA.enabletbls(b);
             showit(Cmd.ShowC.Remember))
          | setit (Cmd.SetC.PrintActions(b)) =
            (Flags.printactions := b; showit(Cmd.ShowC.PrintActions))
          | setit(Cmd.SetC.Help) = print
            ("set debug n               sets debug level n (positive integer)\n"^
             "set threshold n           set rehash threshold n (1 to 100)\n"^
             "set hashdepth n           set depth of hashvalue computation\n"^
             "set rewrite b             set agent rewriting on or off\n"^
             "set remember b            set commitment remembering on or off\n"^
             "set print actions b       set printing of prefixes as actions on or off\n"^
             "set ?                     show this text\n")
            
        and showit(Cmd.ShowC.Debug) =
            print("Debug level = "^(Lib.mkstrint(!Flags.tracelevel))^"\n")
          | showit(Cmd.ShowC.Threshold) =
            print("Rehash threshold = "^(Lib.mkstrint(floor(100.0*(H.get_rehash_threshold()))))^"\n")
          | showit(Cmd.ShowC.Hashdepth) =
            print("Hashdepth = "^(Lib.mkstrint (!A.hashdepth))^
                  (if (!A.hashdepth <> !FA.hashdepth) then " ("^(Lib.mkstrint(!FA.hashdepth))^")\n" else "\n"))
          | showit(Cmd.ShowC.Rewrite) = 
            print("Agent rewriting is "^(if !Flags.rewrite then "on" else "off")^"\n")
          | showit(Cmd.ShowC.Remember) = 
            print("Commitment recording is "^(if O.enabledtbls() then "on" else "off")^"\n")
          | showit (Cmd.ShowC.PrintActions) =
            print((if !Flags.printactions then "Printing" else "Not printing")
                  ^" prefixes as actions\n")
          | showit(Cmd.ShowC.Tables) =
            (print "pi:\n";O.desctbls(); A.desctbls();
             print("Fusion:\n");Fsem.desctbls(); FA.desctbls())
          | showit(Cmd.ShowC.Version) = print ((!version)^"\n")
          | showit(Cmd.ShowC.Help) = print
            ("show debug                show debug level\n"^
             "show threshold            show rehash threshold\n"^
             "show hashdepth            show hashdepth\n"^
             "show rewrite              show agent rewriting setting\n"^
             "show remember             show commitment remembering setting\n"^
             "show print actions        show how prefixes are printed\n"^
             "show version              show MWB version\n"^
             "show tables               show commitment tables\n"^
             "show all          show most of above things\n"^
             "show ?                    show this text\n")
          | showit(Cmd.ShowC.All) =
            app showit [Cmd.ShowC.Version,Cmd.ShowC.Debug,Cmd.ShowC.Threshold,Cmd.ShowC.Hashdepth,Cmd.ShowC.Rewrite,Cmd.ShowC.Remember,Cmd.ShowC.PrintActions]

end
