functor FAgent(structure SL : SORTEDLIST;
	       structure H : HASHTABLE;
	       structure Eq : EQUIV;
	       structure T : COND;
	       sharing Eq = T.E;
	       structure Act : FACTION;
	       sharing Act.N = T.N;
	       sharing Act.F = Eq
	       structure E : ENV;
	       structure V : VAR;
	       sharing E.V = V) : FAGENT =
struct
	
   structure T = T
   structure N = T.N
   structure E = E
   structure Act = Act

   datatype agent = Nil
     		  | Prefix of Act.action * agent
		  | Conc of N.name list * agent
		  | Match of T.cond * agent
                  | Sum of agent list
                  | Parallel of agent list
		  | Scope of N.name * agent
                  | AgentID of string
		  | Applic of agent * N.name list

(*    datatype env = (agent * int) E.env *)

   exception SemanticsError of string * agent

   exception WrongArgs of string

   (* see also makstr below *)
   fun mkstr(Nil) = "0"
     | mkstr(Prefix(a,P)) =
       if not (!Flags.printactions)
	   then (Act.mkstr a) ^ "." ^ (mkstr P)
       else
	   (Act.mkstr a)^
	   (case P of
		Conc(n,Q) =>
		    "<"^(Lib.mapconcat N.mkstr n ",")^">."^(mkstr Q)
	      | _ =>
		    "."^(mkstr P))
     | mkstr(Conc(n,P)) =
       "["^(Lib.mapconcat N.mkstr n ",")^"]"^(mkstr P)
     | mkstr(Match(t,P)) = (T.mkstr t)^(mkstr P)
     | mkstr(Sum(P)) = "(" ^ (Lib.mapconcat mkstr P " + ") ^ ")"
     | mkstr(Parallel(P)) = "(" ^ (Lib.mapconcat mkstr P " | ") ^ ")"
     | mkstr(A as Scope(n,P)) =
       let fun nu(Scope(n,P)) =
	   let val (m,q) = nu(P)
	   in (n::m,q) end
	     | nu (P) = ([],P)
	   val (nv,P') = nu(A)
       in
	   "("^(Lib.mapconcat (if Flags.trace() then
			       (fn n=>"("^(N.pretty_name(n))^")")
			       else N.mkstr) nv ",")^")"
	   ^(mkstr P')
       end
     | mkstr(AgentID(I)) = I
     | mkstr(A as Applic(P,arg)) =
       (case P of
	    AgentID(I) => (mkstr P)
	  | _ => "("^(mkstr P)^")")
	    ^ "<" ^ (Lib.mapconcat N.mkstr arg ",") ^ ">"



   and eq (Nil,Nil) = true
     | eq (Prefix(a,P),Prefix(b,Q)) =
       Act.eq(a,b) andalso eq(P,Q)
     | eq (Conc(a,P),Conc(b,Q)) =
       Lib.eq N.eq (a,b) andalso eq(P,Q)
     | eq (Match(t1,p1),Match(t2,p2)) =
       T.eq(t1,t2) andalso eq(p1,p2)
     | eq (Sum(P),Sum(Q)) =
       Lib.eq eq (P,Q)
     | eq (Parallel(P),Parallel(Q)) =
       Lib.eq eq (P,Q)
     | eq (Scope(n1,P1),Scope(n2,P2)) =
       (* N.eq (n1,n2) andalso *) eq(P1,P2)
     | eq (AgentID(I1),AgentID(I2)) = I1 = I2 
     | eq (Applic(P1,N1),Applic(P2,N2)) =
       eq (P1,P2) andalso Lib.eq N.eq (N1,N2)
     | eq (_,_) = false

   and ceq C (P,Q) =
       let fun nceq C (n1,n2) = T.implies(C,T.match(n1,n2))
	   fun cq (Nil,Nil) = true
	     | cq (Prefix(a,P),Prefix(b,Q)) =
	       Act.eeq (T.equiv C) (a,b) andalso cq (P,Q)
	     | cq (Conc(a,P),Conc(b,Q)) =
	       Lib.eq (nceq C) (a,b) andalso cq (P,Q)
	     | cq (Match(t1,p1),Match(t2,p2)) =
	       T.ceq C (t1,t2) andalso cq (p1,p2)
	     | cq (Sum(P),Sum(Q)) = Lib.eq cq (P,Q)
	     | cq (Parallel(P),Parallel(Q)) = Lib.eq cq (P,Q)
	     | cq (Scope(n1,P1),Scope(n2,P2)) = cq(P1,P2)
	     | cq (AgentID(I1),AgentID(I2)) = I1 = I2 
	     | cq (Applic(P1,N1),Applic(P2,N2)) =
	       cq (P1,P2) andalso Lib.eq (nceq C) (N1,N2)
	     | cq (_,_) = false
       in
	   cq (P,Q)
       end

   val hashdepth = ref 1

   fun hashval P = 
       let fun hv 0 _ = 0
	     | hv _ (Nil) = 0
	     | hv m (Prefix(a,P)) = sxmash(Act.hashval(a),hv (m-1) P)
	     | hv m (Conc(n,P)) = (Lib.fold (fn (n,s)=>(N.code n)+s) n 0)+(hv m P)
	     | hv m (Match(t,P)) = sxmash(5,hv m P)
	     | hv m (Sum(PP)) = Lib.fold sxmash (map (hv m) PP) 7
	     | hv m (Parallel(PP)) = Lib.fold sxmash (map (hv m) PP) 11
	     | hv m (Scope(n,P)) = sxmash(13,hv m P)
	     | hv m (AgentID(I)) = Lib.fold (fn (c,v)=>sxmash(v,(ord c)-(ord #"@"))) (explode I) 17
	     | hv m (Applic(P,n)) = sxmash(hv m P,19)
       in
	   hv (!hashdepth) P
       end

   (* from cmulisp *)
   and sxmash(place,wth) =
       let val total = 26 (* This should probably change, since SML ints are larger than CMULisp's *)
	   val rotate = 7
       in  (* (wth>>(total-rotate))
	      ^place
	      ^((wth&((1<<(total-rotate))-1))<<rotate) *)
	   Lib.xorb(Lib.xorb(Lib.rshift(wth,total-rotate),place),
		     Lib.lshift(Lib.andb(wth,
					   Lib.lshift(1,total-rotate)-1),
				 rotate))
(* **** cmulisp 17e has this code which it claims is an improvement,
        but it's much worse at least in MWB. /bv 941012
	(place>>(total-rotate))
	^wth
	^((place&((1<<(total-rotate))-1))<<rotate)
	   Lib.xorb(Lib.xorb(Lib.rshift(place,total-rotate),wth),
		     Lib.lshift(Lib.andb(place,
					   Lib.lshift(1,total-rotate)-1),
				 rotate))
**** *)
       end


   fun mkstdtbl(sz) =
       H.maketable(sz,hashval,eq,Nil,Nil)
   val stdtbl = ref(mkstdtbl(23));

   fun cleartbls() = stdtbl := mkstdtbl(23);
   fun desctbls() =
       	let fun round(f) = ((Lib.mkstrint (trunc f))^"."
			    ^(Lib.mkstrint(trunc (100.0*
						   (f - (real (trunc f)))))))
	    fun desc(tb) =
	    (Lib.mkstrint (H.entrycount(tb)))
	    ^"/"^(Lib.mkstrint (H.bucketcount (tb)))
	    ^(if (H.entrycount (tb) > 0) then
	      " ("^(round (real (H.entrycount (tb))/real (H.bucketcount (tb))))^")"
	      else "")
	    ^" entries/buck"
	    ^", size "^(Lib.mkstrint (H.size (tb)))
	    ^(if (H.bucketcount (tb) > 0) then
	      " ("^(round (100.0*(real (H.bucketcount (tb))/real (H.size (tb)))))^"% full)"
	      else "")	    
	    ^(if (H.entrycount (tb) > 0) then
	      " ("^(round (real (H.entrycount (tb))/real (H.size (tb))))^" ent/size)"
	      else "")	    
	    ^", hits: "^(Lib.mkstrint (H.hits tb))
	    ^(if !Flags.tracelevel > 1 andalso (H.entrycount tb) < 10
		  then
		      Lib.fold (fn (s,r) => (s^r)) (H.maphash (fn (k,v)=>
				      "\n"
				      ^(mkstr k)
				      ^"\n "
				      ^(mkstr v))
			       tb) ""
	      else "")
	in
	    print("std_form tbl: "^(desc (!stdtbl))^"\n")
	end
    val enabletbld = ref true		(* table usage is enabled *)
    fun enabletbls(b) = enabletbld := b	(* enable/disable *)
    fun enabledtbls() = !enabletbld	(* is usage enabled? *)


   fun mk_sum(pp) =
       let fun flatten_sum([]) = []
	     | flatten_sum (Sum(P)::R) =
	       (flatten_sum P)@(flatten_sum R)
	     | flatten_sum (Nil::R) = flatten_sum(R)
	     | flatten_sum (A::R) = A::flatten_sum(R)
	   val pq = flatten_sum(pp)
       in
	   case pq of
	       [] => Nil
	     | [h] => h
	     | _ =>
		   if !Flags.space_over_speed andalso Lib.eq eq (pp,pq)
		       then Sum(pp)
		   else
		       Sum(pq)
       end
   and mk_parallel(pp) =
       let fun flatten_parallel([]) = []
	     | flatten_parallel(Parallel(P)::R) =
	       (flatten_parallel P)@(flatten_parallel R)
	     | flatten_parallel(Nil::R) =
	       flatten_parallel(R)
	     | flatten_parallel(A::R) =
	       A::(flatten_parallel R)
	   val pq = flatten_parallel(pp)
       in
	   case pq of
	       [] => Nil
	     | [h] => h
	     | _ =>
		   if !Flags.space_over_speed andalso Lib.eq eq (pp,pq)
		       then Parallel(pp)
		   else Parallel(pq)
       end

   (* returns a list of the free names in an agent *)
   fun free_names(P) =
       let fun freen(Nil,_) = nil
	     | freen (Prefix(a,P),lvl) = (Act.free_names(a,lvl))@(freen(P,lvl))
	     | freen (Conc(n,P),lvl) =
	       Lib.foldl (fn (n,l) => 
			  if N.is_free(n,lvl) then
			      (N.free(n,lvl))::l
			  else l) n (freen(P,lvl))
	     | freen (Match(t,P),lvl) =
	       (T.free_names(t,lvl))@(freen(P,lvl))
	     | freen (Sum(pp),lvl) = Lib.mapcan (fn p=>freen(p,lvl)) pp
	     | freen (Parallel(pp),lvl)= Lib.mapcan (fn p=>freen(p,lvl)) pp
	     | freen (Scope(n,P),lvl) = freen(P,lvl+1)
	     | freen (AgentID I,lvl) = nil
	     | freen (Applic(P,n),lvl) =
	       Lib.foldl (fn (n,l) => 
			  if N.is_free(n,lvl) then
			      (N.free(n,lvl))::l
			  else l) n (freen (P,lvl))
       in
	   SL.sort N.le true (freen(P,0))
       end

   fun identifier_def (AgentID(I),E) = id_def(I,E)
   and identifier_arity (AgentID(I),E) = id_arity(I,E)
   and id_def(I,E) = 
       let val (d,a) = E.lookup(V.mkvar I, E)
       in d
       end 
   and id_arity(I,E) =
       let val (d,a) = E.lookup(V.mkvar I, E)
       in a
       end

   fun names(P,env) =
       let fun names(Nil,E,_) = []
	     | names(Prefix(A,P),E,L) = SL.sort N.le true ((Act.names A)@(names(P,E,L)))
	     | names(Conc(n,P),E,L) = SL.merge N.le true (n,names(P,E,L))
	     | names(Match(T,P),E,L) = SL.sort N.le true ((T.names(T))@(names(P,E,L)))
	     | names(Sum([]),_,_) = []
	     | names(Sum(h::t),E,L) = SL.sort N.le true ((names(h,E,L))@(names(Sum(t),E,L)))
	     | names(Parallel([]),_,_) = []
	     | names(Parallel(h::t),E,L) = SL.sort N.le true ((names(h,E,L))@(names(Parallel(t),E,L)))
	     | names(Scope(n,P),E,L) = SL.add N.le true (n,names(P,E,L))
	     | names(AgentID(I),E,IL) =
	       let fun member(_,[]) = false
		     | member(x,h::t) = x = h orelse member(x,t)
	       in				(* foo yuck. *)
		   if member(I,IL) then []
		   else
		       names(id_def(I,E),E,I::IL)
	       end
	     | names(Applic(P,arg),E,IL) =
	       SL.merge N.le true (SL.sort N.le true arg,names (P,E,IL))
       in
	   names(P,env,[])
       end

   (* val apply: identifier * args * env -> agent *)
   fun apply (P as (AgentID(I)), args,env) =
       let val Q = id_def(I,env)
	   val a = id_arity(I,env)
       in
	   if length(args) <> a then
	       raise SemanticsError("definition arity mismatch: "^(mkstr P)^" takes "^(Lib.mkstrint a)^" arguments, you supplied "^(Lib.mkstrint(length args))^": <"^(Lib.mapconcat N.mkstr args ",")^">",P)
	   else
	       beta_reduce Q (rev args,0)
       end

   (* val beta_reduce : agent -> (name list * lambdacount) -> agent  *)
   and beta_reduce P (E as (args,lc))  =
       (* #### look at args to see if we're going to do nothing; *)
       (* e.g. (3,2,1,0) where max(fn(P))<=3 *)
       (* this is cheap if we have fn(P), but we don't. *)
       let val _ = if !Flags.tracelevel > 5 then
	   Lib.dprint(1,"beta "^(mkstr P)^" (["^(Lib.mapconcat N.mkstr args ",")^
		      "],"^(Lib.mkstrint lc)^")") else ()
	   val P' = zbeta_reduce P E
       in
	   (if !Flags.tracelevel > 5 then
		Lib.dprint(~1,"=> "^(mkstr P')^"\n") else ();
	    if !Flags.space_over_speed andalso eq(P,P')
		then (if !Flags.tracelevel > 3 then print("*beta to same: "^(mkstr P)^" (["^(Lib.mapconcat N.mkstr args ",")^"],"^(Lib.mkstrint lc)^")\n") else ();P)
	    else P')
       end
   and zbeta_reduce P ([],_) = P
     | zbeta_reduce Nil E = Nil
     | zbeta_reduce (P as (AgentID I)) E = P
     | zbeta_reduce (Scope(n,P)) (arg,lc) =
       Scope(n,beta_reduce P (arg,lc+1))
     | zbeta_reduce (Prefix(act,P)) E =
       Prefix(Act.beta_reduce act E,beta_reduce P E)
     | zbeta_reduce (Conc(n,P)) E =
       Conc(map (fn n=> N.beta_reduce n E) n,beta_reduce P E)
     | zbeta_reduce (Match(t,P)) E =
       Match(T.beta_reduce t E,beta_reduce P E)
     | zbeta_reduce (Sum(PP)) E =
       Sum(map (fn P => beta_reduce P E) PP)
     | zbeta_reduce (Parallel(PP)) E =
       Parallel(map (fn P => beta_reduce P E) PP)
     | zbeta_reduce (Applic(P,n)) E =
       Applic(beta_reduce P E,map (fn n=>N.beta_reduce n E) n)

   and conc_all (Conc(n,P),_) = (0,n,P)
     | conc_all (Scope(n,P),e) =
       let val (s,nl,p) = conc_all(P,e)
       in (s+1,nl,p) end
     | conc_all (P,_) = (0,[],P)

   and std_form(P,e) =
       (if !Flags.tracelevel > 5 then print("* std_form("^(mkstr P)^")\n") else ();
	let val s =
	    case (if !enabletbld then H.gethash(P,!stdtbl) else NONE) of
		SOME x => x
	      | NONE => 
		    let val x = ztd_form(P,e)
		    in
			if !enabletbld then
			    H.puthash(P,x,!stdtbl)
			else ();
			x
		    end
	in
	    if !Flags.tracelevel > 5 then print("=> "^(mkstr s)^"\n") else ();
	    if !Flags.space_over_speed andalso eq(s,P)
		then P
	    else
		s
	end)

   and ztd_form (Nil,_) = Nil
     | ztd_form (Conc(n,P),env) =
       Conc(n,std_form(P,env))

     | ztd_form (Scope(n,P),env) =
       let val Q = std_form(P,env)
	   fun beta_swap(R) =
	       substitute([(N.mkname("",0),N.mkname("",1)),
			   (N.mkname("",1),N.mkname("",0))],R)
       in
	   case Q of
	       Conc(m,R) =>
		   (* (^n)[n]R => (^n)[n]R *)
		   if Lib.exists N.zerop m then Scope(n,Q)
		   (* (^n)[m]R => [m](^n)R *)
		   else Conc(Lib.map N.pred m,std_form(Scope(n,R),env))
	     | Nil => Nil
	     | _ =>
		   Scope(n,Q)
       end
     | ztd_form (P as AgentID I,env) = P
     | ztd_form (A as Applic(P,n),env) =
       (case P of
	   AgentID _ => A
	 | _ => 
	       let val args = application_args(A,env)
	       in
		   apply(P,args,env)
	       end)

     | ztd_form (Parallel(PP),env) =	(* (P | [x]Q) = [x](P|Q) *)
       (fn () =>
       let val QQ = map (fn P => std_form(P,env)) PP
	   fun is_process x = arity(x,env) = 0
	   fun is_concretion x = arity(x,env) >= 0
	   fun maknames (from,downto) =
	       if from < downto then []
	       else if from = downto then [N.mkname("", from)]
	       else (N.mkname("",from))::(maknames (from-1,downto))
	   fun mknames (n,max) =
	       maknames (n+max,n)
	   fun id(x,y) =
	       (if !Flags.tracelevel > 5 then print("**mknames("^(Lib.mkstrint x)^","^(Lib.mkstrint y)^")\n") else ();
		let val nl = mknames(x,y)
		in
		    if !Flags.tracelevel > 5 then print (" => ["^(Lib.mapconcat N.mkstr nl ",")^"]\n") else ();
		       nl
	       end)
	   
       in
	   if Lib.forall is_process QQ then mk_parallel(QQ)

	   else if Lib.forall is_concretion QQ then
	       (* (x)[yx]Q | (z)[zw]B  =>  (x)(z)[yxzw](Q|B) *)
	       (* (x)[yx]Q | (z)[zw]B  =>  (x)(z)[(yx)++bf zw](Q++bf | B++f) *)
	       (* = (x)(z)[beta|>>z|(yx) zw](beta|>>z|Q | beta|z,>>x|B) *)
	       let val (nnu,vars,b) =
		   Lib.foldr (fn (q,(n,v,b)) =>
			 let val (n',v',q') = conc_all(q,env)
			     val f = (free_names q')
				 @(Lib.filter (fn x=>N.is_free(x,n')) v')
			     val bf = (Lib.mapcan free_names b)
				 @(Lib.filter (fn x=> N.is_free(x,n)) v)
			     val qargs =
				 if null f then []
				 else	(* add n to names up to this  *)
				     mknames(n,N.code(Lib.max N.le f))
			     val bargs =
				 (if null bf then []
				  else maknames(n'+(N.code(Lib.max N.le bf)),
						n'+n))
				 @(maknames(n-1,0))
			 in (n'+n,((map (fn n=>N.beta_reduce n (qargs,0)) v')
				   @(map (fn n=>N.beta_reduce n (bargs,0)) v)),
			     (beta_reduce q' (qargs,0))
			     ::(if null bf orelse n' = 0 then b
				else
				    map (fn bb=>beta_reduce bb (bargs,0)) b)
			     )
			 end) QQ (0,[],[])
		   fun nuify (n,p) =
		       if n = 0 then p
		       else nuify(n-1,Scope(N.Zero,p))
	       in
		   nuify(nnu,Conc(vars,mk_parallel(b)))
	       end
	   else mk_parallel(QQ)
       end)()
     | ztd_form (P,_) = P

   and arity (p,env) =
       let val p = std_form(p,env)	(* too many uses of std_form *)
	   fun ar (Conc(m,_)) = length m
	     | ar (Scope(_,p)) = ar(p)
	     | ar _ = 0
       in
	   ar p
       end

   (* don't like using std_form here, *)
   and is_concretion (P,Env) =
       let val q = std_form(P,Env)
	   fun izc(q) =
	       case q of 
		   Conc(_,_) => true
		 | Scope(_,p) => izc(p)
		 | _ =>  false
       in izc(q) end
   and is_process (P,Env) = not (is_concretion(P,Env))

   (* ################ *)
   and substitute([],p) = p
     | substitute(eXvList, p) =
       let val f = free_names p
	   val dense = if null f then [] else N.fill (Lib.del_dups N.eq f) (* [Lib.max N.le f] *)
	   val sted = Lib.del_dups (fn ((_,a),(_,b)) => N.eq(b,a)) (Lib.sort (fn ((_,a),(_,b)) => N.le(b,a)) eXvList)
	   fun idify ([],[]) = []
	     | idify ([],x) = [] 
	     (* Rest of names to be substituted for are not free, skip them *)
(* raise Lib.disaster("idify([],["^(Lib.mapconcat (fn (a,b)=>"("^(N.mkstr a)^","^(N.mkstr b)^")") x ",")^"]) when eXv=["^(Lib.mapconcat (fn (a,b)=>"("^(N.mkstr a)^","^(N.mkstr b)^")") eXvList ",")^" in p="^(mkstr p)) *)
	     | idify (n::r,l as (p as (e,v))::s) =
	       if N.eq(n,v) then p::(idify (r,s))
	       else (n,n)::(idify (r,l))
	     | idify (n::r,[]) =
	       map (fn x=>(x,x)) (n::r)
	   val fied = idify (dense,sted)
	   val tituted = beta_reduce p ((map #1 fied),0)
       in
	   (if !Flags.tracelevel > 5 then
		print("** substitute ["^(Lib.mapconcat (fn (a,b) => (N.mkstr a)^"/"^(N.mkstr b)) eXvList ",")^"] in "^(mkstr p)^"\n idified: "^(Lib.mapconcat (fn (a,b) => (N.mkstr a)^"/"^(N.mkstr b)) fied ",")^"\n"^"-> "^(mkstr tituted)^"\n")
	    else ();
	    tituted)
       end
	   
   (* papp: (x)[yx]P @ (z)[zw]Q => (xz){yx=zw}.(P|Q) *)
   (*                         (xz){beta|>>z|yx = beta|z,>>x|zw}.(P>>z|Qz>>x *)
   (*       (x)P @ (z)Q => (xz)1.(P|Q) *)
   (* a.P | 'c.Q >[a=c]M f.R, (P@Q)>M f.R *)
   and pseudo_apply (F,C,env) =
       let fun maknames (from,downto) =
	       if from < downto then []
	       else if from = downto then [N.mkname("", from)]
		    else (N.mkname("",from))::(maknames (from-1,downto))
	   fun mknames (n,max) =
	       maknames (n+max,n)
	   fun papp(F,C,env,revp) =
	       let val (ms,xs,F') = conc_all(std_form(F,env),env)
		   val (ns,ys,C') = conc_all(std_form(C,env),env)
		   val _ = if length xs <> length ys then
		       raise SemanticsError("arity mismatch in pseudo_apply: "^(mkstr F),C)
			   else ()
		   val f = (free_names F')@(Lib.filter (fn x=>N.is_free(x,ms))
					    xs)
		   val c = (free_names C')@(Lib.filter (fn x=>N.is_free(x,ns))
					    ys)
		   val fargs = if null f then []
			       else	(* add n to names up to this  *)
				   mknames(ns,N.code(Lib.max N.le f))
		   val cargs = (if null c then []
				else maknames(ms+(N.code(Lib.max N.le c)),
					      ms+ns))
		               @(maknames(ns-1,0))
		   fun mk_sc(n,p) =
		       if n = 0 then p
		       else mk_sc(n-1,Scope(N.Zero,p))
		   val _ = if !Flags.tracelevel>2 then
		       Lib.dprint(0,"ms: "^(Lib.mkstrint ms)^" xs: "^(Lib.mapconcat N.mkstr xs ",")^"\n"
				  ^"ns: "^(Lib.mkstrint ns)^" ys: "^(Lib.mapconcat N.mkstr ys ",")^"\n"
				  ^"fargs: "^(Lib.mapconcat N.mkstr fargs ",")
		       ^"cargs: "^(Lib.mapconcat N.mkstr cargs ","))
		       else ()
	       in
		   mk_sc(ms+ns,
			 Prefix(Act.mk_fusion(map (fn x=>N.beta_reduce x (fargs,0)) xs,
					      map (fn x=>N.beta_reduce x (cargs,0)) ys),
				mk_parallel([beta_reduce F' (fargs,0),
					     beta_reduce C' (cargs,0)])))
	       end
	   val _ = if !Flags.tracelevel>2 then
	       Lib.dprint(1,"pseudoapply: "^(mkstr F)^" * "^(mkstr C)) else ()
	   val v = papp(F,C,env,false)
	   val _ = if !Flags.tracelevel>2 then
	       Lib.dprint(~1,"=> "^(mkstr v)) else ()
       in
	   v
       end

   and makstr(Nil,_) = "0"
     | makstr(Prefix(a,P),nl) =
       if not (!Flags.printactions) then
	   (Act.makstr (a,nl)) ^ "." ^ (makstr (P,nl))
       else
	   (Act.makstr (a,nl))^
	   (case P of
		Conc(n,Q) =>
		    "<"^(Lib.mapconcat (fn n=> N.makstr(n,nl)) n ",")
		    ^">."^(makstr (Q,nl))
		  | _ =>
			"."^(makstr(P,nl)))
     | makstr(A as Conc(n,P),nl) =
       "["^(Lib.mapconcat (fn n=>N.makstr(n,nl)) n ",")
       ^"]"^(makstr (P,nl))
     | makstr(Match(t,P),nl) =
       (T.makstr (t,nl))^(makstr (P,nl))
     | makstr(Sum(PP),nl) =
       "(" ^ (Lib.mapconcat (fn p=>makstr(p,nl)) PP " + ") ^ ")"
     | makstr(Parallel(PP),nl) =
       "(" ^ (Lib.mapconcat (fn p=>makstr(p,nl)) PP " | ") ^ ")"
     | makstr(A as Scope(n,P),nl) =
       let fun nu(Scope(n,P),l,ns) =
	   let val (l as (h::t)) = nl_add(n,l)
	   in nu(P,l,h::ns) end
	     | nu (P,l,ns) = (l,P,ns)
	   val (nnl,P',nv) = nu(A,nl,[])
       in
	   "("^(Lib.mapconcat (fn x=>x) (rev nv) ",")
	   ^")"^(makstr (P',nnl))
       end
     | makstr(AgentID(I),_) = I
     | makstr(A as Applic(P,args),nl) =
       (case P of
	    AgentID(I) => (makstr (P,nl))
	  | _ => "("^(makstr (P,nl))^")")
	    ^"<"^(Lib.mapconcat (fn n=>N.makstr(n,nl)) args ",")
	    ^">"

   and nl_add (n,l) =
       let val s = N.pretty_name(n)
	   val member = Lib.member (op =)
	   val i = length l
	   fun checked s 0 =
	       if not(member(s,l)) then s else checked s (i+1)
	     | checked s i =
	       if not(member(s^(Lib.mkstrint i),l)) then s^(Lib.mkstrint i)
	       else
		   checked s (i+1)
       in
	   if size s > 0 then
	       (checked s 0)::l
	   else (checked "~v" 0)::l
       end
	   

   and mk_nil () = Nil
   and mk_prefix(a,p) = Prefix(a,p)
   and mk_match(t,p) = Match(t,p)
   and mk_concretion([],p) = p
     | mk_concretion(n,p) = Conc(n,p)
   and mk_scope(n,p) = Scope(n,p)
   and mk_identifier(s) = AgentID(s)
   and mk_application(p,[]) = p
     | mk_application(p,n) = Applic(p,n)

   and id_noargs (I,e) =
       0 = id_arity(I,e)

   and is_nil(Nil,_) = true
     | is_nil(AgentID I,e) =
       id_noargs(I,e) andalso is_nil(id_def(I,e),e)
     | is_nil _ = false
   and is_prefix(Prefix _,_) = true
     | is_prefix(AgentID I,e) =
       id_noargs(I,e) andalso is_prefix(id_def(I,e),e)
     | is_prefix _ = false
   and is_match(Match _,_) = true
     | is_match(AgentID I,e) =
       id_noargs(I,e) andalso is_match(id_def(I,e),e)
     | is_match _ = false
   and is_sum(Sum _,_) = true
     | is_sum(AgentID I,e) =
       id_noargs(I,e) andalso is_sum(id_def(I,e),e)
     | is_sum _ = false
   and is_parallel(Parallel _,_) = true
     | is_parallel(AgentID I,e) =
       id_noargs(I,e) andalso is_parallel(id_def(I,e),e)
     | is_parallel _ = false
   and is_scope(Scope _,_) = true
     | is_scope(AgentID I,e) =
       id_noargs(I,e) andalso is_scope(id_def(I,e),e)
     | is_scope _ = false
   and is_identifier(AgentID _,_) = true
     | is_identifier _ = false
   and is_application(Applic _,_) = true
     | is_application(AgentID I,e) =
       id_noargs(I,e) andalso is_application(id_def(I,e),e)
     | is_application _ = false

   and prefix_act(Prefix(a,p),_) = a
     | prefix_act(AgentID I,e) = 
       if id_noargs(I,e) then prefix_act(id_def(I,e),e)
       else raise Lib.disaster("prefix_act")
     | prefix_act _ = raise Lib.disaster("prefix_act")
   and prefix_agent(Prefix(a,p),_) = p
     | prefix_agent(AgentID I,e) =
       if id_noargs(I,e) then prefix_agent(id_def(I,e),e)
       else raise Lib.disaster("prefix_agent")
     | prefix_agent _ = raise Lib.disaster("prefix_agent")
   and match_cond(Match(t,p),_) = t
     | match_cond(AgentID I,e) =
       if id_noargs(I,e) then match_cond(id_def(I,e),e)
       else raise Lib.disaster("match_cond")
     | match_cond _ = raise Lib.disaster("match_cond")
   and match_clause(Match(t,p),_) = p
     | match_clause(AgentID I,e) =
       if id_noargs(I,e) then match_clause(id_def(I,e),e)
       else raise Lib.disaster("match_clause")
     | match_clause _ = raise Lib.disaster("match_clause")
   and sum_summands(Sum(pp),_) = pp
     | sum_summands(AgentID I,e) =
       if id_noargs(I,e) then sum_summands(id_def(I,e),e)
       else raise Lib.disaster("sum_summands")
     | sum_summands _ = raise Lib.disaster("sum_summands")
   and parallel_pars(Parallel(pp),_) = pp
     | parallel_pars(AgentID I,e) = 
       if id_noargs(I,e) then parallel_pars(id_def(I,e),e)
       else raise Lib.disaster("parallel_pars")
     | parallel_pars _ = raise Lib.disaster("parallel_pars")
   and application_args(Applic(p,n),_) = n
     | application_args(AgentID I,e) = 
       if id_noargs(I,e) then application_args(id_def(I,e),e)
       else raise Lib.disaster("application_args")
     | application_args _ = raise Lib.disaster("application_args")
   and application_identifier(Applic(p as (AgentID I),n),_) = p
     | application_identifier(AgentID I,e) = 
       if id_noargs(I,e) then application_identifier(id_def(I,e),e)
       else raise Lib.disaster("application_identifier")
     | application_identifier _ = raise Lib.disaster("application_identifier")
   and scope_name(Scope(n,_),_) = n
     | scope_name (AgentID I,e) =
       if id_noargs(I,e) then scope_name(id_def(I,e),e)
       else raise Lib.disaster("scope_name")
     | scope_name _ = raise Lib.disaster("scope_name")
   and scope_agent(Scope(_,A),_) = A
     | scope_agent(AgentID I,e) =
       if id_noargs(I,e) then scope_agent(id_def(I,e),e)
       else raise Lib.disaster("scope_agent")
     | scope_agent _ = raise Lib.disaster("scope_agent")
   and concretion_names(Conc(n,p),_) = n
     | concretion_names(AgentID I,e) =
       if id_noargs(I,e) then concretion_names(id_def(I,e),e)
       else raise Lib.disaster("concretion_names")
     | concretion_names _ = raise Lib.disaster("concretion_names")
   and concretion_agent(Conc(n,p),_) = p
     | concretion_agent(AgentID I,e) =
       if id_noargs(I,e) then concretion_agent(id_def(I,e),e)
       else raise Lib.disaster("concretion_agent")
     | concretion_agent _ = raise Lib.disaster("concretion_agent")

end
